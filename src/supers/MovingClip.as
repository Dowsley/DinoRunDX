package supers {		import flash.geom.Point;	import util.BC;	import util.RU;		public class MovingClip extends Clip {				public var vel:Point;		public var roomDel:Boolean=false;		private var world:String;		public var velXMax:Number;		public var near:Boolean;		public var oNear:Boolean;		public var ip:Point;		public var gA:Number=1;		public var nearG:Boolean=true;		public var vd:Object;		public var RR:Boolean=false;		public var jumpC:int=0;		//public var hc:Number=1;				//////////////////////////////////////////////////		//////////////////////////////////////////////////				override public function nulls () {						super.nulls();						vel=null;			ip=null;			vd=null;					}						//aply velocity		public function applyForces () {						//gravity			vel.offset (0,ph.g*gA);									//special for Dino			if (o.typ=="Dino") {								//stillness				if (near) {										if (Math.abs(vel.x)<.3) { vel.x=0 }									}				//velmax				if (vel.x>velXMax) { vel.x=velXMax }				if (vel.x<-1*velXMax) { vel.x=-1*velXMax }							}						//velocity vector cannot exceed radius			if (!Config.FAST) {			var vv:Number=getVV(vel)+.1;			if (vv>ph.r) { vel.x*=(ph.r/vv); vel.y*=(ph.r/vv)  }			}										//position ajusted by hc			var hc:Number=brain.hc;			var vel2:Point = vel.clone();			vel2.x*=hc;			if (jumpC==0) { vel2.y*=hc }			pos.offset (vel2.x,vel2.y);					}				public function applyVel (v:Point) {						//velocity vector cannot exceed radius			var vv:Number=getVV(vel)+.1;			if (vv>ph.r) { v.x*=(ph.r/vv); v.y*=(ph.r/vv)  }			//			pos.offset (v.x,v.y);					}				//broadcast object over MP		public function broadcastObj (desc) {						o.mpid=brain.mpids++;			brain.sys.MP.sendToRoom (desc+";mpid:"+o.mpid) ;			//sys.bc=new BC(this);						}				//remote update		/*public function remoteUpdate (px,py,vx,vy) {						sys.ru.upd(px,py);			vel.x=vx;			vel.y=vy;					}*/				//init		override public function init (obj,br,ms):void {						//more init from superClass			super.init (obj,br,ms);						//special volcano?			if (brain.world.sp=="V2") { if (brain.sys.vData.v.World1["b"+roomID]!=undefined) { roomID="b"+roomID } }						//assign vector data			getVD();						//velocity			var vx:Number=(o.vx==undefined)?0:o.vx;			var vy:Number=(o.vy==undefined)?0:o.vy;			vel = new Point (vx,vy);			if (o.rd) {roomDel=true; o.addToRD=true}						//intersect point			ip = new Point(0,0);						//max velocity			velXMax=ph.r;						//define world			world = brain.world.cWorld;						//low grav?			gA=(brain.S.lowGrav)?(brain.S.mod=="PlanetD" ? .9 : .5):1;		}				//this object's room deleted 		override public function roomDeleted ():void {			roomDel=true;						}				//this object's room added 		override public function roomAdded ():void {			roomDel=false;					}				// delete all		override public function deleteAll() {						//brain.deleteClip(this);			if (o.rData) { brain.deleteData(roomID,o.id) }			deleteObj();					}				//save pos and vel to room data		public function savePos():void {						if (o.rData) {				o.px=pos.x;				o.py=pos.y;				o.vx=vel.x;				o.vy=vel.y;			} else if (o.addToRD) {								o.px=pos.x;				o.py=pos.y;				o.vx=vel.x;				o.vy=vel.y;				brain.sys.rData.r.World1[roomID].push (o);							}		}				//give velocity vecctor		public function getVV (v) {						return Math.sqrt((v.x*v.x)+(v.y*v.y));					}										//function common to all MovingClips		public function mainMC () {						//var p:Point=pos.clone();						//apply forces to object			applyForces();			//check current room position			var tmpRX:uint = Math.ceil((pos.x)/brain.sDim.w);			var tmpRY:uint = Math.ceil((pos.y)/brain.sDim.h);						//outside bounds? if not, check for room changes			if (tmpRX<=0||tmpRY<=0||tmpRX>brain.world.xNum||tmpRY>brain.world.yNum) {								if (o.nam=="Raptor") { 					//if (o.debug) { o.remote=true };					if (tmpRY>brain.world.yNum) {						//trace ("down");						if (brain.S.mod=="MP") {							if (!o.remote) {								pos.y=50;								y=50;								/*brain.sys.MP.sendToRoom("DD");								brain.res=true;								inter=false;*/								return;							} else {								pos.y-=200;								y-=200;								/*brain.sys.MP.remoteDisconnect(o.mpID);								inter=false;								return;*/							}						} else {							pos.y=50;							y=50;							/*brain.ret=true;							inter=false;							return;*/						}					} else if (tmpRX>brain.world.xNum) { inter=false; return }									} else if (!RR) { deleteAll() }							} else if (roomA[0]!=tmpRX||roomA[1]!=tmpRY) {								//if this item is part of room data, delete from old room and add to new				if (o.rData) {										var rData:Object = brain.sys.rData.r.World1[roomID];										//delete					for (var i in rData) {												if (o.id==rData[i].id) {														rData.splice (i,1);							break;													}											}										//add					 brain.sys.rData.r.World1["r"+tmpRX+"_"+tmpRY].push (o);										//if this new room is visible, adjust room flag					var vRooms:Array = brain.world.cRooms;					var vis:Boolean=false;					for each (var room:Array in vRooms) {												if (room[0]==tmpRX&&room[1]==tmpRY) {														vis=true;							roomAdded();							break;													}											}					if (!vis) { roomDeleted() }									}								//roomID				roomA = [tmpRX,tmpRY];				roomID = "r"+roomA[0]+"_"+roomA[1];				if (brain.world.sp=="V2") { if (brain.sys.vData.v.World1["b"+roomID]!=undefined) { roomID="b"+roomID } }				roomChange();								//vector data for this current room				getVD();								} 						if (roomDel) { if (!RR) {								//if it's away from dino, save data and remove object and clip				var dist:Number=x-brain.dino.x;				if (dist<-1600||dist>2400) {																savePos();					deleteObj();					//deleteClip();										}									} }						//run functions common to all Clips			mainC();					}				public function getVD () {						var vData:Object = brain.sys.vData.v.World1;			var tmpID:String=(brain.world.sArr[roomID]=="blank")?"r"+roomA[0]+"_"+((roomA[1])+1):roomID;			vd = (vData[tmpID]==undefined)?{}:vData[tmpID].lns;									}				public function roomChange () {};				//final actions		override public function finalActions():void {						//newPos();			x=pos.x;			y=pos.y;					}				// move the clip to a new position		public function newPos():void {						x=pos.x;			y=pos.y;					}			}}