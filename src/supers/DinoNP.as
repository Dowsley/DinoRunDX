package supers {		import flash.display.MovieClip;	import flash.geom.Point;		import fx.ColorChange;	import fx.Flip;		import gfx.Raptor;		import supers.MovingClip;
		public class DinoNP extends MovingClip {				public var accelL:Number=-.2;		public var accelR:Number=.2;		public var accelMax:Number;		public var accelMaxBase:Number;		public var accelF:Number;		public var accelFBase:Number;		public var ang:Number=0;		public var keys:Object;		public var cc:ColorChange;		public var angI:uint;		private var skyA:int=-1;		private var skyC:int;		private var skyR:int;		private var skyI:int;						// appearance		public var dir:String; 		public var oDir:String;		public var app:String="";		public var baseApp:String;		public var gait:String;		public var oApp:String;		public var oGait:String;		public var deg:Number=180/Math.PI;		public var dirA:int=1;		public var jumping:Boolean=false;		private var angA:Array=[0,0,0,0,0];		public var num:int;		var revC:int=0;		public var hitG:Boolean=false;		public var oHitG:Boolean=false;						override public function init (o,br,ms):void {			//set type and clip			o.typ="Dino";						//init from MovingClip			super.init (o,br,ms);			NN=true;						keys={};						//initial physics properties			ph.sh = "circ"		//shape			if (o.rd) { skyA=rand(0,23)*15; skyR=rand(2,5); skyC=0; skyI=(rand(0,1)==0)?-15:15 }						//color variation			cc = new ColorChange (this);			var c:uint = rand (0,10);			var m:Number = rand2 (.6,1);			cc.cChange ([c,c,c,m,m+rand2(0,.4),m,1]);						if (brain.S.gh) {				if (Math.random() < .5 && o.nam=="Cera"){					dark = true;					cc.cChange ([-255,-255,-255,0,0,0,.5]);				} else {					cc.cChange ([255,255,255,1,1,1,.25]);				}				//graphic.alpha = .25;			}											}				public var dark:Boolean = false;				override public function nulls () {						super.nulls();			cc.nulls();			cc=null;			keys=null;			angA=null;					}				// MAIN LOOP				public function mainDino () {						revC++;			moveDino(near?1:4);						//end temp app?			if (master.body.ends) { app="" }						//base app			baseApp = (app!="")?app.substring (0,4):"";			//air and ground appearance			if (!near) {								jumping=true;								//set new velXMax?				if (oNear) { velXMax=(Math.abs(vel.x)<2)?2:Math.abs(vel.x-1) }								//jump				app=baseApp="jump";				gait=(vel.y<2)?"Runs":"Walk";				ang=(vel.y<2)?ang:0;							} else {								//landing?				if (!oNear) {										skyA=-1;					jumping=false;					velXMax=ph.r;									}								//stick to downhill slopes more, run faster up hills				if (vel.y>-.5&&Math.abs(vel.x)>2) { vel.offset (0,jumping?0:.4) } else { vel.offset (0,-.2) }								//ground gait				if (Math.abs(vel.x)<.3) { gait="Still"; } else {										if (Math.abs(vel.x)>=.3&&Math.abs(vel.x)<=1) { gait="Stroll" } else {											if (Math.abs(vel.x)>1&&Math.abs(vel.x)<=5) { gait="Walk" } else {														gait="Runs";													}											}										}								//make app the gait				app=baseApp=gait							}			oNear=near;						//face left or right			if (vel.x<-.2) { dir="L"; dirA=1 }			if (vel.x>.2) { dir="R"; dirA=-1 }			if (oDir!=dir) { graphic.gotoAndStop (dir) }			oDir=dir;						//exception for jumping			if (baseApp=="jump") { app+=gait }						//add angle			var ang2=ang*deg*dirA;			if (ang2>180) { ang2-=360 }			if (ang2<-180) { ang2+=360 }						//average last 5 out for stego/cera, to prevent chop			if (o.nam=="Stego"||o.nam=="Cera"||o.nam=="Para") {												angA.shift();				angA.push (ang2);				var sum:Number=0;				for each (var a in angA) { sum+=a }				ang2=sum/angA.length;				//				num=(Math.round((ang2)/angI))*angI;								//limit angle of travel				if (num>45) { num=45; if (o.nam!="Para") { rev() } }				if (num<-45) { num = -45 }							} else {							num=(Math.round((ang2)/angI))*angI;				if (num>60) { num = 60 }				if (num<-60) { num = -30 }							}						if (num<0) { num=Math.abs(num)+1 }			app+=num;								//final appearance			if (skyA!=-1) { 							skyC++; 				if (skyC>=skyR) {										skyC=0;					skyA+=skyI; 					if (skyA<0) { skyA=345 }					if (skyA>345) { skyA=0 }									}				app="flip"+skyA 							}			//if (o.nam=="Para") { trace (app) }			if (oApp!=app&&sys.flip==undefined) { try { master.body.gotoAndPlay (app) } catch(e){}; master.body.ends=false }			//			oApp=app;			oGait=gait;						//nobody like you			if (brain.S.NL) {				if (dir == "R" && pos.x > brain.dino.pos.x) {					rev();				} else if (dir == "L" && pos.x < brain.dino.pos.x) {					rev();				}			}						//Runs functions common to all MovingClips			mainMC ();		}				// KEY INPUT		private function moveDino(f) {			if (keys.L) {								accelL-=accelF;				if (accelL<-1*accelMax) { accelL=-1*accelMax }				vel.x+=accelL/f;							} else {								accelL+=accelF;				if (accelL>-.4) { accelL=-.4 }							}						if (keys.R) {								accelR+=accelF;				if (accelR>accelMax) { accelR=accelMax }				vel.x+=accelR/f;							} else {								accelR-=accelF;				if (accelR<.4) { accelR=.4 }							}					}		//				//jump		public function jump (lvl) {						if (!jumping&&near) {								jumping=true;				vel.x+=(lvl)*Math.sin(ang);				vel.y-=(lvl*2)*Math.cos(ang)+(vel.y>0?Math.abs(vel.y)/2.5:0);				pos.y-=.5;						}					}				public function JAContact (obj) {						jump (obj.o.lvl);					}				public function rev () {						if (revC>10) { revC=0; if (keys.R) { keys.L=true; keys.R=false } else if (keys.L) { keys.R=true; keys.L=false } }					}						//misc		public function switchNear (val) {						near=val;					}									// REACTIONS				public function bounce (v) {						if (!v)				return;						vel.x=v.x;			vel.y=v.y;					}				public function bUp (obj) {						if (obj.o.lvl<4) {				pos.offset (vel.x<0?-1:1,-2);				vel.offset (vel.x<0?-2:2,-2);			}					}				//public var crushed:Boolean = false;				public function crush (obj) {						var allow:Boolean=false;			var dTouch:Boolean=(obj.o.nam=="Raptor")?true:false;			if (obj.o.nam=="Meteorite") {				if (obj.smc<25&&obj.o.lvl>0) {					dTouch=obj.dTouch;					if (o.nam=="Para") {						if (obj.o.lvl>2) {							allow=true;							if (o.dinoR!=null) { o.dinoR.endRide() }						}					} else if (o.nam=="Stego"||o.nam=="Cera") {						if (obj.o.lvl>2) { master.extraA.inter=false; allow=true }					} else { allow=true }				}			} else { allow=true }			if (allow) { if (sys.flip==undefined) {								//audio				switch (o.nam) {										case "Cera": brain.sys.audio.ply ("ceraCrush",.6,false); break;					case "Stego": brain.sys.audio.ply ("stegoCrush",.6,false); break;					case "Para": brain.sys.audio.ply ("ceraCrush",.6,false); break;									}								sys.flip=new Flip(this,getVV(obj.vel),brain);				if (dTouch && brain.S.mod != "MP") {					brain.sys2.stats.addFood(o.nam,master.pData.score);					brain.create ( {nam:"FoodScore", px:x, py:y, foodTyp:o.nam, depth:["world","main"]} );									}				brain.create ( {nam:"Bone", px:x+rand(-9,9), py:y+rand(-6,3), vx:vel.x+rand(-6,6), vy:rand(-12,-2), depth:["world","main"]} );								if (brain.S.sl || (obj is Raptor && obj.gore)) {					//brain.dino.bdc = 1;					obj.bdc = 1;					var ll=rand(20,50);					if (brain.S.mod == "MP" ) {						ll=rand(10,20)					}					for (var ii:uint=1; ii<=ll; ii++) { brain.create ({nam:"Blood", px:x+rand(-30,30), py:y+rand(-12,12), vx:obj.vel.x+rand(-8,40), vy:rand(-20,0), depth:["world","main"]}) }					ll=rand(8,15);					if (brain.S.mod == "MP") {						ll=rand(3,7)					}					for (var ii:uint=1; ii<=ll; ii++) { brain.create ( {nam:"Bone", px:x+rand(-20,20), py:y+rand(-6,0), vx:vel.x+rand(-10,30), vy:rand(-24,-2), depth:["world","main"]} ) };				}							} }								}				override public function finalActions():void {						newPos();					}					}	}