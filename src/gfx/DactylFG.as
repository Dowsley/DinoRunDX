package gfx {		import flash.display.MovieClip;		import base.Brain;		import fx.ColorChange;	import fx.Grabbed;		import supers.MovingClip;
		public class DactylFG extends MovingClip {				public var xm:Number;		public var ym:Number;		public var txm:Number;		public var tym:Number;		private var cc:ColorChange;		private var yA:Number=0;		public var feeler:Object;		public var dClose:Boolean=false;		public var odc:Boolean=false;		public var grabbing:Boolean=false;		public var MP:Boolean=false;		public var BC:Boolean=false;		public var mpc:int=0;		private var tx:Number;		private var ty:Number;		private var bd:int;		var minXM:Number;		var dc:Object;		private var eggChance:int;				public function DactylFG (o,br):void {						//dino init			var v:int = Math2.randInt(1,4);			switch (v) {				case 1:				case 2:					assignGFX(new _DactylFG);					break;				case 3:					assignGFX(new _DactylFG2);					break;				case 4:					assignGFX(new _DactylFG3);					break;			}						mouth = graphic.mouth;			feet = graphic.feet;			eye = graphic.eye;						super.init (o,br,this);			eggChance = brain.S.ED ? 120 : 1000;									if (o.remote) {								xm=txm=o.xm;				ym=tym=o.ym;				tx=x=pos.x+(xm*3);				ty=y=pos.y;							} else {								xm=txm=12.25*brain.dino.accelMax;				ym=tym=0;							}						minXM=brain.doom.xMov+.5;						//extra physics properties			ph.sh = "circ";		//shape			ph.f = 0;			//friction			ph.bn = 0;			//bounce			ph.g = 0;			//gravity			ph.m = 20;			//mass			ph.r = 16			//radius						//random color variation			var offR:int=0;			var offG:int=0;			var offB:int=0;			switch (brain.S.colorV) { 							case "B": offR=offB=rand(-20,-40); offG=-10; break ;				case "C": offR=offG=offB=rand(-20,-40); break ;							}			if (o.wait) { txm=xm=rand2(.8,1.5); tym=ym=rand2(-.22,-.18); offG=0; offR=-20; offB=-40 }			if (brain.S.BC) {offG=40; offR=-30; offB=30}						if (!brain.S.pk) {							cc = new ColorChange (this);				var c:uint = brain.rand (0,10);				var m:Number = rand (.8,1);				cc.cChange ([c+offR,c+offG,c+offB,m,m+rand(0,.4),m,1]);						}						//feeler			hasExtra=true;			feeler = brain.create ( {nam:"FeelerG", px:x, py:y, master:this, r:120, depth:[0,0]} );						//brodcast			if (brain.S.mod=="MP") {								MP=true;				if (!o.remote) {										ym=rand2(-1,1.1);					BC=true; 					broadcastObj ("OC"+"px:"+rnd(o.px)+";py:"+rnd(o.py)+";xm:"+rnd2(xm)+";ym:"+rnd2(ym)+";rdt:0;nam:DactylFG");									}							}						//boulder holder?			if ((!o.wait&&brain.S.lv>2&&!brain.S.balloons&&!brain.S.BC&&!brain.S.gh) || brain.S.pk) {								if ((rand(0,(brain.S.dCH==0)?6:15)==0) || brain.S.pk) {								if (brain.S.pk) {						o.boulder=true;						bd=rand(-100,400); 						pid = rand(1,2)						feet.gotoAndStop ("pumpkin"+pid);					} else {						o.boulder=true;						bd=rand(-100,100); 						feet.gotoAndStop ("boulder"+(brain.S.colorV=="V"?"V":""));						pos.y-=1000;					}									}							}						if (brain.S.gh) {				cc = new ColorChange (this);				cc.cChange ([255,255,255,1,1,1,.25]);			}							}				public var pid:int = 0;				override public function nulls() {						super.nulls();			if (cc) {				cc.nulls();			}			cc=null;			dc=null;					}				public function feelerGContact () {						yA=.333*(brain.dino.accelMax+.25);					}				public function rnd2 (num) {						return ((Math.round(num*100))/100)					}				public function remoteUpdate (px,py,vx,vy) {						tx=Number(px)+(xm*3);			ty=Number(py);			txm=vx;			tym=vy;						//snap?			if (Math.abs(tx-x)>250) { x=tx };					}				public var mouth:MovieClip;		public var eye:MovieClip;		public var feet:MovieClip;				public function squawk ():void {			mouth.gotoAndPlay ("squawk"); 			brain.sys.audio.ply ("squawk"+rand(1,3),rand2(.1,.2),false);		}				public function main ():void {						if (brain.S.gh && dc) {				tym-=.5;				alpha-=.004;				if (alpha < 0) {					deleteAll();				}							}						if (!MP) {								var HH:Boolean = brain.S.HH;				var xa:Number = brain.S.ED ? rand2(0,.05) : 0;				var ya:Number = 0;				if (dc && HH) {					if (dc.keys.R)						xa += .05;					if (dc.keys.L)						xa -= .1;					/*if (dc.keys.U)						ya -= 1;					if (dc.keys.D)						ya += .1;*/				}				if (Brain.dinoGrabbed && !dc) {					txm = brain.dino.grabbedBy.txm;					if (txm<minXM) { txm=minXM }				}				txm+=(rand2(-.1,.1) + xa);				txm = Math.min (txm,(dc && HH ? 14 : 15))				if (!HH)					if (txm<minXM&&!o.wait) { txm=minXM }				if (HH)					tym+=((o.wait)?rand2(-.022,-.016):rand2(-.2,.2)-yA);				else					tym+=((o.wait)?rand2(-.022,-.016):rand2(-.2,.205)-yA);				//tym += ya;				if (tym<-5) { tym=-5 }							} else {								if (BC) {										//broadcasted movement					mpc++;					if (mpc>=40) {												mpc=0;						txm+=rand2(-.3,.3);						tym+=rand2(-.7,.71)-yA;						if (tym<-5) { tym=-5 }						brain.sys.MP.sendToRoom ("OU"+o.nam+";"+o.mpid+";"+Math.round(x)+";"+Math.round(y)+";"+rnd2(txm)+";"+rnd2(tym));											}									} else {										//remote info movement					tx+=xm;					ty+=ym;					x+=(tx-x)/15;					y+=(ty-y)/15;								}										}						xm+=(txm-xm)/8;			ym+=((tym-ym)/4)-((o.wait)?0:yA*4);						x+=(xm*brain.hc);			y+=(ym*brain.hc);						pos.x=x;			pos.y=y;						//squawk?			if (!brain.S.gh && rand(0,500)==0) { 				if (mouth.currentFrame==1) { 					mouth.gotoAndPlay ("squawk"); brain.sys.audio.ply ("squawk"+rand(1,3),rand2(.1,.2),false);				}			}						//lay egg?			if (rand(0,eggChance)==0) { if (!grabbing) {								//expression				if (mouth.currentFrame==1) { mouth.gotoAndPlay ("squawk") }				eye.gotoAndPlay ("lay");								//lay it				brain.create ( {nam:"Egg", px:x-6, py:y-15, vx:xm+rand(-6,6), d:true, depth:["world","main"] } )							} }			//drop blouder?			if (o.boulder) {												if (x-brain.dino.x>bd) {										o.boulder=false;					feet.gotoAndPlay ("in");					if (brain.S.pk) {						brain.create ({nam:"Boulder", px:x-9, py:y+18, vx:xm, vy:0, lvl:pid, colorV:2, rd:true, dact:true, pumpkin:true, pid:pid, depth:["world","main"]});					} else {						brain.create ({nam:"Boulder", px:x-9, py:y+18, vx:xm, vy:0, lvl:4, colorV:2, rd:true, dact:true, depth:["world","main"]});					}														}							}						//remove?			var dist=x-brain.dino.pos.x;			if (dist>1000||dist<-1000) { deleteAll() }						//grab dino?			if (dc!=null) {								if (dc.sys.grabbed==undefined && !brain.S.ED && !dc.near && dc.baseApp!="poun" && (yA==0||o.wait)&&!o.boulder) {									feet.gotoAndPlay ("grab");					dc.sys.grabbed=new Grabbed(dc,this,(o.wait==true)?true:false) 					if (o.wait) { o.wait=false; txm=12.25*dc.accelMax; tym=0 }									}						}						yA=0;			dc=null;						//dino close			if (brain.dino.sys.grabbed==undefined&&!o.boulder) {								if (dClose) { 									if (!odc) {												feet.gotoAndPlay ("out") 											} 									} else { 									if (odc) {												feet.gotoAndPlay ("in") 											}									}							}			odc=dClose;			dClose=false;						/*if (gt) {				alpha-=.005;				if (alpha < 0) {					deleteAll();				}			}*/		}				public function dinoClose()  { dClose=true }				public function dinoContact(dino) {						dc=dino;						if (brain.S.pk) {				if (pid == 1) {					dino.collectPumpkin();					pid = 0;					feet.gotoAndPlay ("in");					o.boulder = false;				} else if (pid == 2) {					//dino.hurt2();					brain.create ({nam:"Boulder", px:x-9, py:y+18, vx:xm, vy:0, lvl:pid, colorV:2, rd:true, dact:true, pumpkin:true, pid:pid, depth:["world","main"]});					pid = 0;					feet.gotoAndPlay ("in");					o.boulder = false;				}			}											}				public function removeExtras() {									feeler.deleteAll();			feeler=null;			hasExtra=false;					}			}	}