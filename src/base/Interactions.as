package base {		import flash.geom.Point;		public class Interactions {				private var I:Array; //info for objects		//public  var vData:Object // vector data reference		private var brain:Object		private var circHit:Boolean;				public function Interactions (b) {			this.brain=b;		}				public function init () {						//reset info array			I = [[],[]];					}				//////////////////////////////////////////////////		//////////////////////////////////////////////////				// COLLISIONS				private function distSQ(a:Point, b:Point) : Number {			var cX:Number = a.x-b.x;			var cY:Number = a.y-b.y;			return (cX*cX + cY*cY);		}		private var gh:Array = ["DactylRed","Runner","LizG","LizO","LizP","Worm","Fish","StegoA","Para","CeraA","BirdFG"];//"DactylFG",				public function circ_circ (a:Object,b:Object,acts:Array):Boolean {						var ap:Point=a.pos;			var bp:Point=b.pos;			var d:Number=(a.big||b.big)?0:ap.x-bp.x;			if (d<50) { if (d>-50) {								var near:Boolean = false;				var aph:Object = a.ph;				var bph:Object = b.ph;				var rads:int=aph.r+bph.r				var len:int=Point.distance(ap,bp);				/*var rads:int=(aph.r+bph.r) * (aph.r+bph.r);				var len:int=distSQ(ap,bp);*/				if (len<rads) {										/*rads = Math.sqrt(rads);					len = Math.sqrt(len);*/					var ang:Number=0;					near=true;					init();										//trace (a.o.nam,b.o.nam)										if (b.o.nam=="CeraA" && b.dad.dark) {						brain.dino.darkTouched();					} else if (brain.S.gh && (a.o.nam == "Raptor" || a.o.nam == "Boulder") && gh.indexOf(b.o.nam)>-1) {												if (!b.gt) {							b.gt = true;							b.ghostTouched();							a.speedBoost (1.4,100);							brain.sys.audio.ply ("misc1",.1,false);						}						return false;					}															//if this is a bounce reaction, bounce both objects					if (acts[0][0]=="bounce" && !(b.soft && b.bounced)) {												if (b.soft)							b.bounced = true;											//find penetration						var pen:Number=len-rads;												//normalize the vector between both midpoints						var nv1:Point = new Point (ap.x-bp.x,ap.y-bp.y);						nv1.normalize (1);																		//highest velocity object moves out						var av:Point = new Point (nv1.x*(pen),nv1.y*(pen));						var avv:Number = (a.vel.x*a.vel.x)+(a.vel.y*a.vel.y);						var bvv:Number = (b.vel.x*b.vel.x)+(b.vel.y*b.vel.y);						var ride:Boolean=false;												if (a.o.nam=="Raptor") {														if ((a.str || (brain.S.sl))) {// && a.baseApp=="poun"																if (b.o.nam=="Meteorite") { if (b.o.lvl<4) { b.crush(a); return false } }								else if (b.o.nam=="Boulder"||b.o.nam=="StegoA"||b.o.nam=="CeraA"||(b.o.nam=="Para"&&(brain.gState=="win"))) {//brain.gState=="win"||a.baseApp=="poun"																		if (!b.o.crushed) {										b.crush(a);										b.o.crushed = true;										if (brain.S.sl) {											a.pounceBounce();										}									}																	} 								return false;							}														if (a.nearG) { bvv=9000 }							var ang2:Number=Math.atan2(bp.y-ap.y,bp.x-ap.x);							if (b.ride) { if (ang2>.6) { if (ang2<2.5) { if (a.sys.noRide==undefined) { ride=true; avv=10000 } } } }													} 						if (avv>bvv) { a.applyVel (new Point (-1*av.x,-1*av.y)) } else { b.applyVel (av) }													//find intersection point						a.ip.x=ap.x-(nv1.x*aph.r);						a.ip.y=ap.y-(nv1.y*aph.r);												//create normal of midpoint vector						var wall:Point = normal (nv1);						if (a.o.typ=="Dino") { if (a.o.nam!="Stego"&&a.o.nam!="Cera") { a.ang =  Math.atan2 (wall.y,wall.x) - Math.PI } }																		//ride or reg physics?						if (ride) {														var allow:Boolean=true;							if (a.riding!=null) { if (a.riding.o.nam=="Para") { if (a.riding!=b) { allow=false } } }							if (allow) { a.riding=b }							I[0].push (bounce (a.vel,wall,aph.f-.15,0));							I[1].push (0);													} else {													//project vel1 onto wall							//var p1w:Point = proj (0,wall,aph.f);							var p1w:Point = proj (a.vel,wall,aph.f);														//project vel1 onto wall normal (bph.bn (or .9) instead of aph.bn so dino can push and bounce boulders)							var b2:Boolean=false;							if (b.o.nam=="Boulder") { if (b.o.lvl<4) { b2=true } };							var p1n:Point = (a.o.typ=="Dino")?proj(a.vel,normal(wall),((ang2>.85&&ang2<2.4)||b2)?.5:((a.vel.x>0&&b.vel.x<0)?.1:.85)):proj(a.vel,normal(wall),aph.bn);														//project vel2 onto wall							var p2w:Point = proj (b.vel,wall,bph.f);														//project vel2 onto wall normal							var p2n:Point = proj (b.vel,normal(wall),(a.o.typ=="Dino")?.9:bph.bn);														//transfer momentum							var P:Point = new Point ((aph.m*p1n.x)+(bph.m*p2n.x),(aph.m*p1n.y)+(bph.m*p2n.y));							var V:Point = new Point ((p1n.x-p2n.x),(p1n.y-p2n.y));							p2n.x=(P.x+(V.x*aph.m))/(aph.m+bph.m);							p1n.x=p2n.x-V.x;							p2n.y=(P.y+(V.y*aph.m))/(aph.m+bph.m);							p1n.y=p2n.y-V.y;																					//add bounce velocity to info							I[0].push (p1w.add(p1n));							I[1].push (p2w.add(p2n));													}					}										end([a,b],acts);														} else if (len-rads<3) { near=true }								//some things should not trigger near				if (b.o.depth[0]==0||b.o.nam=="DactylFG"||b.o.nam=="Raptor") { near=false }								}}						a=null;			b=null;			acts=null;			return near;					}				public function circ_room (a:Object,acts:Array):Boolean {						var near:Boolean = false;			var r:int = a.ph.r;			var p:Point = a.pos;			var vd:Object = a.vd;			var c:int=0;			for each (var ln:Object in vd) {								var d:Number=p.x-(ln.x1+((ln.x2-ln.x1)/2));				if (d<100) { if (d>-100) {									var e:Number=p.y-(ln.y1+((ln.y2-ln.y1)/2));				if (e<100) { if (e>-100) {										var nd:Boolean=(a.o.typ!="Dino")?true:false;					var al:Boolean=true;									var p1:Point = new Point (ln.x1,ln.y1);					var p2:Point = new Point (ln.x2,ln.y2);										//create wall vector					var wv:Point = p2.subtract(p1);										//check to see which side of the vector the circ is closest to					//point 1					var hv:Point;					var v1:Point = p.subtract(p1);					if (v1.x*wv.x+v1.y*wv.y<0) {												if (nd) { al=false } else { hv = v1.clone() }											} else {												//point 2						var v2:Point = p.subtract(p2);						if (v2.x*wv.x+v2.y*wv.y>0) {													if (nd) { al=false } else { hv = v2.clone() }												} else {													//closer to wall							//create normalized left hand normal of wall vector							var wn:Point = normal (wv);							wn.normalize(1);														//project point 1 vector onto normal of wall vector							hv = proj (v1, wn, 1);													}											}										if (al) {											//length of hit vector						var l:Number=hv.length;						//if (a.o.nam=="Raptor") { r=21 }												if (l<r) {														c++;							near=true;							if (a.o.typ=="Dino") { a.ang=Math.atan2 (wv.y,wv.x) }							init();														//it hit a wall							//penetration							var pen:Number = (r-l);														//normalize hit vector							hv.normalize(1);														//move object out							p.offset (pen*hv.x,pen*hv.y) 														//intersect point							a.ip.x=p.x+r*hv.x;							a.ip.y=p.y+r*hv.y;														//bounce or slide:find the new angle, or else just move on to end							if (acts[0][0]=="bounce") { I[0].push (bounce (a.vel,normalR(hv),a.ph.f,a.ph.bn)) }							end([a],acts);													} else if (l-r<4) { near=true }											}										if (c==2) { break }									}}}}			}						a=null;			acts=null;			return near;					}				public function circ2_room (a:Object,acts:Array):Boolean {						var near:Boolean = false;			var r:int = a.ph.r;			var vd:Object = a.vd;						var vv:Number=a.getVV(a.vel);			for (var i:int=0; i<2; i++) {								var p:Point=(i==0)?new Point (a.pos.x-(a.vel.x/2),a.pos.y-(a.vel.y/2)):a.pos;				var hit:Boolean=false;				//var cc:int=0;				for each (var ln:Object in vd) {					//if (a.o.nam=="Raptor") { trace (cc++) }					var d:Number=p.x-(ln.x1+((ln.x2-ln.x1)/2));					if (d<100) { if (d>-100) {											var e:Number=p.y-(ln.y1+((ln.y2-ln.y1)/2));					if (e<100) { if (e>-100) {												var p1:Point = new Point (ln.x1,ln.y1);						var p2:Point = new Point (ln.x2,ln.y2);												//create wall vector						var wv:Point = p2.subtract(p1);												//check to see which side of the vector the circ is closest to						//point 1						var hv:Point;						var v1:Point = p.subtract(p1);						if (v1.x*wv.x+v1.y*wv.y<0) {														hv = v1.clone();													} else {														//point 2							var v2:Point = p.subtract(p2);							if (v2.x*wv.x+v2.y*wv.y>0) {															hv = v2.clone();														} else {															//closer to wall								//create normalized left hand normal of wall vector								var wn:Point = normal (wv);								wn.normalize(1);																//project point 1 vector onto normal of wall vector								hv = proj (v1, wn, 1);															}													}												//length of hit vector						var l:Number=hv.length;												if (l<r) {														hit=true;							a.hitG=true;							near=true;							a.ang=Math.atan2 (wv.y,wv.x);							init();														//it hit a wall							//penetration							var pen:Number = (r-l);														//normalize hit vector							hv.normalize(1);														//move object out							a.pos.offset (pen*hv.x,pen*hv.y) 														//intersect point							a.ip.x=p.x+r*hv.x;							a.ip.y=p.y+r*hv.y;														//bounce							I[0].push (bounce (a.vel,normalR(hv),a.ph.f,a.ph.bn));								//end							end([a],acts);													} else {														a.hitG=false;							if (l-r<5) { near=true }													}											}}}}									}								if (hit) { break }			}						a=null;			acts=null;			return near;					}				public function line_room (l:Object,acts:Array):void {						//line position shortcuts			var lp1:Point = l.pos;			var lp2:Point = l.pos2;						//create line vector and intersection array			var lv:Point = lp2.subtract(lp1);			var iA:Array=[];						//examine all room vectors			//var vd:Object = vData[l.roomID];			var vd:Object={}			for each (var ln in vd) {				//create wall vector				var p1:Point = new Point (ln.x1,ln.y1);				var p2:Point = new Point (ln.x2,ln.y2);				var wv:Point = p2.subtract(p1);								//create a vector from point 1 of line to point 1 of wall				var v1:Point = p1.subtract(lp1);								//ratio of perpendicular products				var t:Number=perP(v1,wv)/perP(lv,wv);				//intersecting?				if (t>0&&t<1) {										var t2:Number=perP(v1,lv)/perP(wv,lv);										if (t2<0&&t2>-1) {												//intersect point						var ip:Point = new Point(lp1.x+(lv.x*t),lp1.y+(lv.y*t));												//add info to intersection array if this wall is closest to line						var dist:Number = Point.distance(lp1,ip);						if (iA.length==3) { if (dist<iA[2]) { iA=[wv,ip,dist] } } else { iA=[wv,ip,dist] }											}									}			}						//examine iA and bounce off closest wall			if (iA.length>0) {								init();								var fwv:Point = iA[0];				var fip:Point = iA[1];								//move line out				lp1.offset (fip.x-lp2.x,fip.y-lp2.y);				lp2.x=fip.x;				lp2.y=fip.y;								//bounce?				if (acts[0][0]=="bounce") {										fwv.normalize(1);					var tmpV:Point = bounce (l.vel,fwv,1,1);										//new data for line					l.bounce (tmpV);										//bring line out a tiny bit so we dont intersect the most recently bounced wall on recusive room tests					l.applyVel2();										//dont call bounce function on line again					I[0].push (0);										//exe this function again with new line info					line_room (l,acts);									} 								end([l],acts);							}		}								public function line_rect (l:Object,r:Object,acts:Array):void {						//line position shortcuts			var lp1:Point = l.pos;			var lp2:Point = l.pos2;						//create rect shortcuts			var w:int=r.ph.w;			var h:int=r.ph.h;			var x1:Number=r.pos.x-(w/2);			var x2:Number=x1+w;			var y1:Number=r.pos.y-(h/2);			var y2:Number=y1+h;						//interpolate 3 or 5 points (depending on length) on the line and see if any intersect the rectangle			var hit:Boolean=false;			var inc:Number=(l.o.l>30)?.25:.5;			for (var i:Number=0; i<=1; i+=inc) {								//interpolate				var ip:Point = Point.interpolate (lp1,lp2,i);								//test				if (ip.x>x1) { if (ip.x<x2) { if (ip.y>y1) {if (ip.y<y2) { hit=true; break } } } }			}						if (hit) {								init();								//find the side the line hit				var fs:Array=[];				var sides:Array = [[new Point (x1,y1),new Point (x2,y1)],								   [new Point (x2,y1),new Point (x2,y2)],								   [new Point (x2,y2),new Point (x1,y2)],								   [new Point (x1,y2),new Point (x1,y1)]]								for each (var side:Array in sides) {										//interpolate midpoint of side					var mp:Point = Point.interpolate (side[0],side[1],.5);										//length of midpoint to lp1					var ll:Number = Point.distance (mp,lp1);										//add to finalSide?					if (fs.length!=0) { if (ll<fs[2]) { fs=[side[0],side[1],ll] } } else { fs=[side[0],side[1],ll] }									}								//define final wall vector				var fwv:Point = fs[1].subtract (fs[0]);								//define actual intersection point				var v1:Point = fs[0].subtract(lp1);				var lv:Point = lp2.subtract(lp1);				var t:Number = perP(v1,fwv)/perP(lv,fwv);				if (t==Infinity||t==-Infinity) { t=.5 }				var fip:Point = new Point(lp1.x+(lv.x*t),lp1.y+(lv.y*t));								//move line out				lp1.offset (fip.x-lp2.x,fip.y-lp2.y);				lp2.x=fip.x;				lp2.y=fip.y;								//bounce the rect?				if (acts[1][0]=="bounce") {										//adjust for mass					var mr = l.ph.m/r.ph.m;										//bounce angle is from center point to intersect point (reversed)					var bv:Point = r.pos.subtract(fip);					bv.x*=mr;					bv.y*=mr;					I[1].push (bv);							  				}								//bounce the line?				if (acts[0][0]=="bounce") {										fwv.normalize(1);					var tmpV:Point = bounce (l.vel,fwv,1,1);										//new data for line					l.bounce (tmpV);										//dont call bounce function on line again					I[0].push (0);									}				//finish				end([l,r],acts);			}					}						public function line_circ (l:Object,c:Object,acts:Array):void {						//var shortcuts			var r:int = c.ph.r;			var cp:Point = c.pos;			var lp1:Point = l.pos;			var lp2:Point = l.pos2;						//create line vector			var lv:Point = lp2.subtract(lp1);						//check to see which side of the line the circ is closest to			//point 1			var hv:Point;			var v1:Point = cp.subtract(lp1);			if (v1.x*lv.x+v1.y*lv.y<0) { hv = v1 } else { hv = cp.subtract(lp2) }						//length of hit vector			var ll:Number=hv.length;						if (ll<r) {								init();								//find intersection point				var i:Number=0;				do {										var ip:Point = Point.interpolate (lp1,lp2,i);					if (Point.distance(ip,cp)>r) { break } else { i+=.1 }									} while (true);								//move line out				lp1.x+=ip.x-lp2.x;				lp1.y+=ip.y-lp2.y;				lp2.x=ip.x;				lp2.y=ip.y;													//define final wall vector (normalized normal of vector from midpoint to intersect point)				var fwv:Point = normal (cp.subtract(ip))				fwv.normalize (1);								//bounce the circ?				if (acts[1][0]=="bounce") {										//adjust for mass					var mr = l.ph.m/c.ph.m;										//bounce angle is from center point to intersect point (reversed)					var bv:Point = cp.subtract(ip);					bv.x*=mr;					bv.y*=mr;					I[1].push (bv);				  				}								//bounce the line?				if (acts[0][0]=="bounce") {										var tmpV:Point = bounce (l.vel,fwv,1,1);										//new data for line					l.bounce (tmpV);										//dont call bounce function on line again					I[0].push (0);									}																//finish				end([l,c],acts);							}		}				public function rect_rect (a:Object,b:Object,acts:Array) {						//create rect A shortcuts			var wA:int=a.ph.w;			var hA:int=a.ph.h;			var x1A:Number=a.pos.x-(wA/2);			var x2A:Number=x1A+wA;			var y1A:Number=a.pos.y-(hA/2);			var y2A:Number=y1A+hA;						//create rect B shortcuts			var wB:int=b.ph.w;			var hB:int=b.ph.h;			var x1B:Number=b.pos.x-(wB/2);			var x2B:Number=x1B+wB;			var y1B:Number=b.pos.y-(hB/2);			var y2B:Number=y1B+hB;						//test			if (x2A>x1B) { 				if (x1A<x2B) { 					if (y2A>y1B) {						if (y1A<y2B) { 													init();														//if this is a bounce reaction, bounce both objects like circles							if (acts[0][0]=="bounce") {																var ap:Point = a.pos;								var bp:Point = b.pos;								var aph:Object = a.ph;								var bph:Object = b.ph;								var rads:int=aph.r+bph.r;								var len:int=Point.distance(ap,bp);														//find penetration								var pen:Number=len-rads;																//normalize the vector between both midpoints								var nv1:Point = new Point (ap.x-bp.x,ap.y-bp.y);								nv1.normalize (1);																//move them out								var av:Point = new Point (nv1.x*(pen/2),nv1.y*(pen/2));								ap.offset (-1*av.x,-1*av.y);								bp.offset (av.x,av.y);															//create normal of midpoint vector								var wall = normal (nv1);																//project vel1 onto wall								var p1w:Point = proj (a.vel,wall,aph.f);																//project vel1 onto wall normal								var p1n:Point = proj (a.vel,normal(wall),aph.bn);																//project vel2 onto wall								var p2w:Point = proj (b.vel,wall,bph.f);																//project vel2 onto wall normal								var p2n:Point = proj (b.vel,normal(wall),bph.bn);																//transfer momentum								var P:Point = new Point ((aph.m*p1n.x)+(bph.m*p2n.x),(aph.m*p1n.y)+(bph.m*p2n.y));								var V:Point = new Point ((p1n.x-p2n.x),(p1n.y-p2n.y));								p2n.x=(P.x+(V.x*aph.m))/(aph.m+bph.m);								p1n.x=p2n.x-V.x;								p2n.y=(P.y+(V.y*aph.m))/(aph.m+bph.m);								p1n.y=p2n.y-V.y;																//add bounce velocity to info								I[0].push (p1w.add(p1n));								I[1].push (p2w.add(p2n));															}												end([a,b],acts);						} 					} 				} 			}														}				public function circ_circ2 (a:Object,b:Object,acts:Array) {						circ_circ (a,b,acts);					}				public function circ2_circ (a:Object,b:Object,acts:Array) {						circ_circ (a,b,acts);					}				public function rect_room (a:Object,acts:Array) {						//treat rectangles like circles for room collisions			circ_room (a,acts);					}				public function rect_circ (a:Object,b:Object,acts:Array) {						//treat rectangles like circles			circ_circ (a,b,acts);					}				public function circ_rect (a:Object,b:Object,acts:Array) {						//treat rectangles like circles			circ_circ (a,b,acts);					}				//////////////////////////////////////////////////////////////////////////////////////		//////////////////////////////////////////////////////////////////////////////////////				//finish off the interaction				private function end(o:Array,acts:Array):void {						//pass info to each object according to action(s)			var indx:int=-1;			for (var id in o) {								var obj:Object=o[id];				indx++;				for (var i in acts[indx]) {										var act=acts[indx][i];					if (I[indx][i]!=0) { obj[act](act=="bounce"?I[indx][i]:o[(id==0)?1:0]) } //(act=="hit")?o[(id==0)?1:0].vel.clone()									}							}			I=null;			o=null;			acts=null;					}				//////////////////////////////////////////////////				// TRIG FUNCTIONS				// project		private function proj (v1,v2,a):Point {						//dot product			var dp:Number = (v1.x*v2.x) + (v1.y*v2.y);						//normalize			var nv:Point = v2.clone();			nv.normalize (1);						return new Point (dp*nv.x*a,dp*nv.y*a);					}				// give left normal		private function normal (v):Point {						return new Point (v.y,-1*v.x);					}				// give right normal		private function normalR (v):Point {						return new Point (-1*v.y,v.x);					}				// bounce		private function bounce (v1,wall,f,b):Point {						//project v1 onto wall			var p1w:Point = proj (v1,wall,f);						//project v1 onto wall normal and reverse			var p1n:Point = proj (v1,normal(wall),b);			p1n.x*=-1;			p1n.y*=-1;						//add and return			return p1w.add (p1n);					}				// perpendicular product		private function perP (v1:Point,v2:Point):Number {						return ((v1.x*v2.y)-(v1.y*v2.x));					}	}	}