package base {		import flash.events.DataEvent;	import flash.events.Event;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.TimerEvent;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.XMLSocket;	import flash.system.Security;	import flash.utils.Timer;	import flash.utils.getTimer;		import gfx.InterF;		import util.LevelStatsMP;
		public class MPManager {				public var banned:Boolean=false;				public var ip:String="";		public var Self:Object;		public var Players:Array;		public var Races:Array;		public var C:XMLSocket;		private var U:URLLoader;		public var current:String;		public var current2:String="";		private var url:String="http://api.xgenstudios.com/?method=xgen.";		private var fcr:Boolean=false;	//first connect msg received? (first if self's id)		private var interF:InterF;		public var serverNum:int;						private var host1:String="dinorun01.xgenstudios.com";//dev.mmocha.com //dinorun01.xgenstudios.com		private var host2:String="dinorun02.xgenstudios.com";		private var host3:String="dinorun03.xgenstudios.com";				private var host1_M2:String = "dinorun01.xgenstudios.com";		private var host2_M2:String = "dinorun02.xgenstudios.com";		private var host3_M2:String = "dinorun02.xgenstudios.com";		private var port1_M2:int = 1227;		private var port2_M2:int = 1227;		private var port3_M2:int = 1228;					private var switching:Boolean=false;		private var portOnline:int=1027;		private var port:int=1033; //normal = 1033 // dev = 1027		private var HBtimer:Timer;		private var FPStimer:Timer;		private var oldCLR:String;		private var oldHat:String;		private var hbc:int=0;		public var lvlstr:String="";		public var finished:int=0;		public var startTime:uint;		private var mpc:int;		public var cOpen=false;		var q:Array;		public var hbc2:int=0;		public var version:int=1119;		public var lowestVersion:int;		public var playersNum:int;				public static const levelBuffer:int = 10;				public var brain:Brain;		private var policyLoaded:Boolean = false;				public var numPlayers:int = 0;		public var DX:Boolean = true; 				public function MPManager (br) {						brain=br;			interF=brain.interF;			serverNum=Brain.ServerNum; // default = 1			DX = true;					}				public function switchServer () {						interF.msgNum=0;			switching=true;			C.close();			unconfig(C);			Connect();					}				public function closeSocket():void		{			trace ("CLOSE SOCKET");			C.close();			unconfig(C);		}				public function initData () {						if (!policyLoaded) {				policyLoaded = true;				//policy file				Security.loadPolicyFile("xmlsocket://" + this["host"+serverNum] + ":" + port);			}						Self = {nam:"", id:"000", pass:"", score:0, lvl:1, clr:"A", hat:"xx", blocked:false, friend:false};			Players=[];			Races=[];			fcr=false;					}						public function XMLLoaded(event:Event):void {						//trace (U.data);						///put a try...catch here?			//trace ("current",current);			if (current!="race") {								var xml:XML = new XML(U.data);				processXML (xml);							}			   		}				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////				public function getStats(who) {						for each (var PL:Object in Players) { if (PL.nam==who || PL.persona==who) { return PL; break } }					}				public function getRank(nam) {						//rankPlayers();			var l:int=Players.length;			for (var i=0; i<l; i++ ) {				 				 var PL:Object=Players[i];				 if (PL.nam==nam || PL.persona==nam) {					 					 return (i+1+"/"+l);					 break;					 				 }				 			}					}								public function rankPlayers() {						Players.sortOn ("score", Array.NUMERIC | Array.DESCENDING);					}				public function rankRaces() {						Races.sortOn ("lvl", Array.NUMERIC | Array.DESCENDING);						//filter out higher levels			var l=Races.length;			for (var i:int=0; i<l; i++ ) {				 				 var R:Object=Races[i];				 var vizLevel:int = Math.max (1,R.lvl - MPManager.levelBuffer);				 if (vizLevel>Self.lvl) { Races.splice (i,1); i--; l-- }				 			}					}															////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////				///////////// CONNECT				public function initAPI () {						initData();			U = new URLLoader();			U.addEventListener(Event.COMPLETE, XMLLoaded);					}				/*public function checkNumPlayers():void		{			trace ("//////////////////// CHECK NUM PLAYERS")			C=new XMLSocket();			C.addEventListener(DataEvent.DATA, C_DataNP);			C.addEventListener(IOErrorEvent.IO_ERROR, C_IOErrorNP);			C.connect(host1,port);		}*/				/*public function C_DataNP(ev:DataEvent) {						var dat:String = new String (ev.data);			if (dat.substr(0,2) == "0k")				interF.updateNumPlayers(dat.substr(2,1000000));			removeNumPlayers();		}*/				/*public function removeNumPlayers() {			trace ("//////////////////// REMOVE NUM PLAYERS")			C.removeEventListener(DataEvent.DATA, C_DataNP);			C.removeEventListener(IOErrorEvent.IO_ERROR, C_IOErrorNP);			C.close();			C = null;		}*/				public function C_IOErrorNP(ev) { }		public var connected:Boolean = false;				public function Connect() {						serverNum=Brain.ServerNum; // default = 1			serverNum = 1;			trace ("/////// CONNECT",serverNum)			//connect			C=new XMLSocket();			FPStimer = new Timer (5100,0);			config(C);			/*CONtimer = new Timer (10000,2);			CONtimer.addEventListener(TimerEvent.TIMER, timeOut);			CONtimer.start();*/			if (Config.MMOCHA2) {				trace (serverNum,this["host"+serverNum+"_M2"],this["port"+serverNum+"_M2"])				C.connect(this["host"+serverNum+"_M2"],this["port"+serverNum+"_M2"]);			} else {				C.connect(this["host"+serverNum],DX ? port : portOnline);			}						connected = true;					}				public function C_Connect (ev) { 						/*CONtimer.stop();			CONtimer.removeEventListener(TimerEvent.TIMER, timeOut);*/			cOpen=true;						if (Config.MMOCHA2 && (current == "login" || current == "create" || switching)) {				C.send("09"+this.attemptedUser+";"+this.attemptedPass)			} else {				interF.C_Success();			}					}		public function C_IOError(ev) { trace ("IO ERROR"); interF.C_Fail() }		public function C_Close(ev) { cOpen=false; unconfig(C); interF.C_Close() }		public function C_SecurityError(ev) {}				/*public function timeOut (ev) {						trace ("timeout")			CONtimer.stop();			CONtimer.removeEventListener(TimerEvent.TIMER, timeOut);			var oldServerNum:int=serverNum;			do { serverNum=rand(1,3) } while (serverNum==oldServerNum)			switchServer();					}*/				private function config(dispatcher:IEventDispatcher):void {			            dispatcher.addEventListener(Event.CLOSE, C_Close);            dispatcher.addEventListener(Event.CONNECT, C_Connect);            dispatcher.addEventListener(DataEvent.DATA, C_Data);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, C_IOError);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, C_SecurityError);			        }				public function unconfig(dispatcher:IEventDispatcher):void {			            dispatcher.removeEventListener(Event.CLOSE, C_Close);            dispatcher.removeEventListener(Event.CONNECT, C_Connect);            dispatcher.removeEventListener(DataEvent.DATA, C_Data);            dispatcher.removeEventListener(IOErrorEvent.IO_ERROR, C_IOError);            dispatcher.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, C_SecurityError);			if (!switching) { undoAPI() }						//if disconnected during race countdown			if (brain.sys2.levelStatsMP!=undefined) { brain.sys2.levelStatsMP.remove() } 						this.connected = false;			        }				public function undoAPI () {						U.removeEventListener(Event.COMPLETE, XMLLoaded);					}																		// give a rounded random number		public function rand(min:int, max:int):int {			return (Math.round(Math.random()*(max-min))+min);		}				//////////////// CREATE NEW ACCOUNT				public function steamSignup():void		{			create (attemptedUser,attemptedPass);		}				public function removeUnderscores(str:String):String		{			return str.split("_").join(".");		}				public function create(user:String,pass:String,email:String="") {						trace ("email: ",email);			current="create";			Self.nam=interF.filter(user);			Self.pass=pass;			Self.guest=false;			if (Config.MMOCHA2) {				attemptedUser = user;				attemptedPass = pass;			}			//var email:String = "pixeljammiles@gmail.com";			var request:String = url+"users.add&v=2&game_id=dinorun&username="+user.toLowerCase()+"&password="+pass.toLowerCase()+(email!=""?"&email_address="+email:"");			trace (request);			U.load(new URLRequest(request));					}				//////////////// LOGIN				private var attemptedUser:String;		private var attemptedPass:String;				public function login(user,pass) {						Brain.log("login: "+user+"/"+pass);			current="login";			Self.nam=interF.filter(user);			Self.pass=pass;			Self.guest=false;			if (Config.MMOCHA2) {				attemptedUser = user;				attemptedPass = pass;				Connect();			} else {				U.load(new URLRequest(url+"users.authenticate&username="+user+"&password="+pass));			}			//trace (url+"users.authenticate&username="+user.toLowerCase()+"&password="+pass.toLowerCase());			//C.send ("00"+Self.id+"HB");					}				public function loginAsGuest() {						current="loginGuest";						//push into players array			Self.nam="Dino"+rand(0,99999)			Self.guest=true;			Self.blocked=false;			Self.friend=false;			Self.isMod = false;			Self.prestige = 1;			Self.persona = "null";			Players.push(Self);						//warp			interF.current="Warp";			interF.showInterX ("Warp");					}		//////////////// GET STATS				public function getUStats() {						current="getStats";			Self.prestige = Self.isMod ? 2 : 1;			U.load(new URLRequest(url+"stats.get&username="+Self.nam.toLowerCase()+"&game_id=dinorun"));					}				//////////////// SET STATS				public function setUStats(id,val) {						//current="setStats";			//trace (url+"stats.submit&username="+Self.nam.toLowerCase()+"&password="+Self.pass.toLowerCase()+"&game_id=dinorun&stat_id="+id+"&value="+val)			if (!Self.guest) {							U.load(new URLRequest(url+"stats.submit&username="+Self.nam.toLowerCase()+"&password="+Self.pass.toLowerCase()+"&game_id=dinorun&stat_id="+id+"&value="+val)) 				if (id=="score") { brain.sys2.stats.addMPScore (Self.nam.toLowerCase(),val) }							}					}				//////////////// INIT SELF STATS ON CREATE NEW USER				public function initUStats() {									Self.score=0;			Self.score=brain.sys2.stats.checkMPScore(Self.nam,Self.score);			Self.clr="A";			Self.hat="xx";			Self.prestige=1;			oldCLR=Self.clr;			oldHat=Self.hat;						//define level			Self.lvl = getLvl (Self.score);						//push into players array			Players.push(Self);						//warp			interF.current="Warp";			interF.showInterX ("Warp");					}				//////////////// SET SELF STATS				public function selfStats(xml:XMLList) {						var gotHat:Boolean=false;			for each (var stat in xml.children()) {								switch (stat.attribute("id").toString()) {										case "score": 					Self.score=Number(stat);					if ((Self.score+Self.score)!=(Self.score*2)) { trace ("INCORRECT SCORE FORMAT"); Self.score=brain.sys2.stats.checkMPScore(Self.nam,0) } else { Self.score=brain.sys2.stats.checkMPScore(Self.nam,Self.score) }					break;										case "clr": stat == -1 ? "a" : Self.clr=interF.dinoColors[Number(stat)]; break;					case "hat": gotHat=true; Self.hat=interF.hatsMP[Number(stat)]; break;										case "eggs": brain.sys2.stats.MPeggs=Number(stat); break;					case "racesWon": brain.sys2.stats.MPracesWon=Number(stat); break;					case "crittersEaten": brain.sys2.stats.MPcrittersEaten=Number(stat); break;					case "doomSurf": brain.sys2.stats.MPdoomSurf=Number(stat); break;					case "boulderRide": brain.sys2.stats.MPboulderRide=Number(stat); break;					case "prestige": Self.prestige = Number(stat);									}							}						//init hat			if (!gotHat) {								current="";				setUStats ("hat",0);				Self.hat="xx";						}						oldCLR=Self.clr;			oldHat=Self.hat;						//define level			Self.lvl = getLvl (Self.score);						//push into players array			Players.push(Self);						//warp			interF.current="Warp";			interF.showInterX ("Warp");					}				public function returnToLobby() {						stopFPStimer();			stopHB2();			interF.newRace={};			lvlstr="";			Races=[];			Players=[];			Players.push(Self);			current="lobbyCheck";					}		//								   0 1 2  3  4   5   6   7    8    9    10   11   12   13    14    15    16    17    18    19    20		static public var lvlsNEW:Array = [0,0,20,75,200,400,750,1000,1500,2000,3000,4500,6000,8000,10000,13000,17000,22000,30000,40000,50000];		static public var lvlsOLD:Array = [0,0,20,75,200,400,750,1000,1500,2000,3000];				public function getLvl (num)		{			var lvl:int=0;			var lvls:Array = Config.UPDATE_ID >= 1 ? lvlsNEW : lvlsOLD;			for (var i:int=0; i<=lvls.length; i++) { if (lvls[i]<=num) { lvl=i } }			//return 20;			return lvl;					}				public function checkLobby() {						trace ("///////////////// CHECK LOBBY");						current = "lobbyCheck";			if (!switching) { interF.go_to("MPLobby") } else { 							Players=[];				Players.push(Self) ;				Races=[];				interF.newRace={};				fcr=false;															}			C.send ("03_");						//private ID			brain.sys2.stats.checkPrivateID(Self.nam);					}				private var mods:Array = [];		private var prestigeHolders:Array = [];				///////////////// HANDLE SOCKET DATA				public function C_Data(ev:DataEvent) {						var dat:String = new String (ev.data);						if (Config.VERBOSE_MP) { trace ("socket data:",dat) }						try {									if (ip!="") { interF.interX.ip.text=ip+" "+dat.substr(2,dat.length-2); ip="" }			var t1:Boolean=false;						if (Config.MMOCHA2) {				if (current == "login" || current == "create" || switching) {					if (switching) {						interF.C_Success();						interF.refreshLobby();						switching=false; 						return;					}					t1=true;					if (dat.substr(0,1) == "A") {						//login successful						var userID:String = dat.substr(1,3);						var name:String = dat.substr(4,20);						var split:Array = name.split("#");						name = split[split.length-1];						var level:int = int(dat.substr(24,1));						var prestigeLvl:int = int(dat.substr(25,1));						if (prestigeLvl > 0) {							prestigeHolders.push(name);							brain.sys2.stats.awardPrestige();						}						if (Config.STEAM_MP) {							Self.persona = Brain.gameStats.getMyPersona();						} else {							Self.persona = "null";						}						if (level > 0) {							Self.isMod = true;							mods.push(name);						} else {							Self.isMod = false;						}						if (current == "create") {							interF.C_Success();						} else {							getUStats();						}					}					if (dat.substr(0,2) == "09") {						//bad username / password						if (Config.STEAM_MP) {							steamSignup();							return;						}						interF.interX.alert.gotoAndStop("a98");						interF.preInitAlert();					}					if (dat.substr(0,3) == "091") {						//banned account					}				} else {					if (dat.substr(0,1) == "U") {						var userID:String = dat.substr(1,3);						var name:String = dat.substr(4,20);						var split:Array = name.split("#");						name = split[split.length-1];						var level:int = int(dat.substr(24,1));						var prestigeLvl:int = int(dat.substr(25,1));						if (level > 0) {							mods.push(name);						}						if (prestigeLvl > 0) {							prestigeHolders.push(name);						}					} else if (dat.substr(0,2) == "0e") {						//boot						var split:Array = dat.split(";");						var time:String = split[0].substr(2);						var msg:String = split[1];						interF.bootMSG = (time=="0"?"":"Banned for "+time+" minutes: ")+msg;					} else if (dat.substr(0,2) == "0g") {						//mod message						var msg:String = dat.substr(2);						interF.modMSG(msg,false);					} else if (dat.substr(0,2) == "0j" && current=="lobby") {						//mod message entire lobby						var msg:String = dat.substr(2);						interF.modMSG(msg,true);					}				}			}						var typ1:String = dat.substr(0,1);			switch (typ1) {								case "M": t1=true; incomingMSG(dat.substr(1,3),dat.substr(4,2),dat.substr(6,dat.length-6)); break;				case "C": t1=true; remoteConnect(dat.substr(1,3)); break;				case "D": t1=true; remoteDisconnect(dat.substr(1,3)); break;							}						if (!t1) {								var typ2:String = dat.substr(0,2);					var resp:String = dat.substr(2,dat.length-2);				switch (typ2) {										case "01": parseRoomList (resp); break;					case "05": processRoomVar (resp); break;					case "09": error(); break;									}							}						if (dat.substr(0,2) == "0k") {				trace ("0k update: "+dat)				numPlayers = int(dat.substr(2,100000));				updateRaceNum();			}						} catch (e:Error) {trace (e.getStackTrace())}					}				public function updateRaceNum() {			if (interF.interX.inRaces)				interF.interX.inRaces.text = "Dinos Currently Racing: " + Math.max (0,(numPlayers - Players.length))		}				public function checkFin () {						var fNum=0;			for each (var P:Object in Players) { if (P.fin) { fNum++ } }			return fNum;					}				public function finishRace () {						interF.winMP(true);			//			var endTime=getTimer();			Self.fTime=endTime-startTime;			sendToRoom ("DF"+Self.fTime);			Self.fin=true;			var fNum:int=checkFin();			if (fNum==1) { brain.sys2.levelStatsMP = new LevelStatsMP (brain,Players.length==1?true:false) }					}				public function rankPlayersEnd () {						var finalA:Array=[];			var playersTime:Array=[];			var playersX:Array=[];			for each (var P:Object in Players) {								if (P.fTime!=0) { playersTime.push (P) } else {										if (P.id==Self.id) {												P.endX=brain.dino.x;						brain.dino.noMov();											} else {												P.endX=brain.rmDinos["d"+P.id].x;						//brain.rmDinos["d"+P.id].noMov();											}											playersX.push (P);														}							}			playersTime.sortOn ("fTime", Array.NUMERIC );			playersX.sortOn ("endX", Array.NUMERIC | Array.DESCENDING);						for (var i:int=0; i<playersTime.length; i++) { finalA.push (playersTime[i].nam) }			for (var j:int=0; j<playersX.length; j++) { finalA.push (playersX[j].nam) }			return finalA;					}				public function addPlayer (id,msg) {			trace (1,id,msg);			if (id!=Self.id) {								if (msg!=undefined) {										var stats:Array=msg.split(";");					//if (stats.length != 5)						//return;					var indx=getPVar(id,"indx");					var prestigePref:int = stats[7]==undefined?1:stats[7];					var nam:String=stats[0].toLowerCase();					if (!hasPrestige(nam)) {						prestigePref = 1;					}					var persona:String = stats[8] == undefined ? "null" : stats[8];					if (indx==-1) {												//invalid?						var pattern:RegExp =/[^a-z0-9.,]/ig;						if (pattern.test(stats[0])) { trace ("INVALID!!!!!!!!!!"); return }												//dupe names?												//if (nam==Self.nam.toLowerCase()) { interF.act_SignOut(0) }						for each(var PL:Object in Players) { if (PL.nam.toLowerCase()==nam) { return } }												//push new player						if (stats[6]<1082) { lowestVersion=1081 }												Players.push ( {nam:stats[0], prestige:prestigePref, id:id, score:Number(stats[1]), lvl:getLvl(Number(stats[1])), clr:catchColor(interF.dinoColors[Number(stats[2])]), hat:interF.hatsMP[Number(stats[3])], blocked:getBlockedStatus(stats[0]), guest:(stats[5]=="true")?true:false, friend:getFriendStatus(stats[0]), version:stats[6],persona:persona} )						interF.updatePlayers();											//new race?						if (stats[4].substr(0,1)=="1") { trace ("GOT RACE FROM ST//////",id,stats[4]); addRace(id,stats[4]) }											} else {												//new colors						Players[indx].clr=catchColor(interF.dinoColors[Number(stats[2])]);						Players[indx].hat=interF.hatsMP[Number(stats[3])];						Players[indx].prestige=prestigePref;						interF.updatePColor(indx,Players[indx].clr,prestigePref);											}									}								return true;							} else { return false }									}				public function catchColor (color):String {			return color == undefined ? "a" : color;		}				public function getIP (id,nam) {						ip=nam;			C.send ("07"+id);					}						public function myRaceToString () {						trace ("nr",interF.newRace);			return interF.newRace.act?"1,"+interF.newRace.nam+","+interF.newRace.curP.join(".")+","+interF.newRace.lvl+","+interF.newRace.maxP+","+interF.newRace.zone+","+interF.newRace.privateID:"0";					}						public function myInfoToString () {						var dclr:int=interF.dinoColors.indexOf(Self.clr);			var dhat:int=interF.hatsMP.indexOf(Self.hat);			if (lowestVersion==1081) {												if (dclr>37) { dclr-=37 }				if (dhat>55) { dhat-=55 }							}			return Self.nam+";"+Self.score+";"+dclr+";"+dhat+";"+myRaceToString()+";"+Self.guest.toString()+";"+version+";"+Self.prestige+";"+(Config.STEAM_MP?Brain.gameStats.getMyPersona():"null");					}				public function isMod(nam:String):Boolean {			if (Config.MMOCHA2) {				return mods.indexOf(nam)!=-1;			}			return interF.isMod(nam);		}				public function hasPrestige(nam:String):Boolean {			return prestigeHolders.indexOf(nam)!=-1;		}										private function incomingMSG (id,typ,msg) {						if (Config.VERBOSE_MP) { trace ("incoming message:",id,typ,msg) }						if (typ!="RD"&&typ!="OU"&&typ!="OC"&&typ!="HB"&&Config.VERBOSE_MP) { trace (id,typ,msg); }						//auth race should work in limbo as well, just in case overload						if (brain.gState=="game"||brain.gState=="win"||Brain.escaped) { 							/////////////				/////////////////////////////////////////////////////////////////////// GAME				/////////////							switch (typ) {										case "RD":						//info from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].act_rmData(msg) }						break;										case "RA":						//toggle rain from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.createRain(); }						break;										case "SI":						//show doom from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].sit(); }						break;										case "WA":						//show doom from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].wave(); }						break;										case "SD":						//show doom from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.freeRun_Doom(2) }						break;										case "HD":						//hide doom from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.freeRun_Doom(1) }						break;										case "SG":						//show gore from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].showGore(); }						break;										case "HG":						//hide gore from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].hideGore(); }						break;										case "TA":					//talk	 from a remote dino						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].showSpeech(interF.filter(msg),id) }						break;																									case "OU":					//updated info about remote objects					brain.updateRemoteObj(msg);					break;										case "FR":					//fps from a remote dino					if (Number(msg)==0) { remoteDisconnect (id) } else { brain.dino.addFPS (id,Number(msg),false) }					break;										case "OC":					//remote object created					brain.createR(msg);					break;										case "SB":					//remote dino speedboost					var msgB:Array=msg.split(";");					if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].speedBoost (Number(msgB[0]),Number(msgB[1])) }					break;										case "DF":					//dino finished race					var ind:int=getPVar(id,"indx");					if (ind!=-1) {												Players[ind].fTime=Number(msg);						Players[ind].fin=true;						var fNum:int=checkFin();						if (fNum==1) {														interF.winMP(false); 							brain.sys2.levelStatsMP = new LevelStatsMP (brain,false);												} else if (fNum>=Players.length) { C.send ("RO") } 										}					break;										case "RO":					//race over					brain.sys2.levelStatsMP.raceOver();					break;										case "IM":					//asteroid impact, start race					brain.impact();					break;										case "DD":					//dino dead					if (brain.sys2.levelStatsMP==undefined) {												brain.sys2.progBar.doom ("d"+id);						interF.showMessage (getPVar(id,"nam")+" is doomed"); 											}					break;									}							} else if (current=="lobby") {				/////////////				/////////////////////////////////////////////////////////////////////// LOBBY				/////////////								switch (typ) {									case "SR":					//Stat Request					var nr:String="0";					C.send("00"+id+"ST"+myInfoToString());					break;										case "ST":					//Stat Return					addPlayer(id,msg);					break;										/*case "XT":					//stat Return B					var nmm=getPVar(id,"nam");					if (nm==-1) { addPlayer(id,msg) }					//exe mem					trace ("//////////////////////// EXE",interF.mem["exe"+id][0],interF.mem["exe"+id][1],interF.mem["exe"+id][2])					incomingMSG (interF.mem["exe"+id][0],interF.mem["exe"+id][1],interF.mem["exe"+id][2]);					delete interF.mem["exe"+id];					//for (var ex in interF.mem) { trace (ex,interF.mem[ex]) }					break;*/										case "CH":					//Chat					var msgA7:Array=msg.split("!@#$!@#&!@#*LlL");					addPlayer (id,msgA7[1]);					interF.showChat (getPVar(id,"nam"),msgA7[0],getPVar(id,"clr"),"Chat")					break;															case "PM":					//private message received					var msgA8:Array=msg.split("!@#$!@#&!@#*LlL");					addPlayer (id,msgA8[1]);					var pmsg:String = msgA8[0];					var sender:String=getPVar(id,"nam");					var booted:Boolean=false;					if (!Config.MMOCHA2) {						if (isMod(sender.toLowerCase())) {							trace ("IS FROM MOD");							if (pmsg.substring(0,5)=="boot.") {								interF.bootMSG=pmsg.substring(5);								booted=true;								trace ("BOOTED")							} else if (pmsg.substring(0,6)=="boot1.") {								interF.bootMSG=pmsg.substring(6);								booted=true;								brain.sys2.stats.boot(1);								trace ("BOOTED 1");							} else if (pmsg.substring(0,6)=="boot2.") {								interF.bootMSG=pmsg.substring(6);								booted=true;								brain.sys2.stats.boot(2);							} else if (pmsg.substring(0,6)=="boot3.") {								interF.bootMSG=pmsg.substring(6);								booted=true;								brain.sys2.stats.boot(3);							} else if (pmsg.substring(0,6)=="boot4.") {								interF.bootMSG=pmsg.substring(6);								booted=true;								brain.sys2.stats.boot(4);							} else if (pmsg.substring(0,6)=="boot5.") {								interF.bootMSG=pmsg.substring(6);								booted=true;								brain.sys2.stats.boot(5);							}							if (booted) {								banned=true;								interF.act_SignOut(0);							}						}					}					if (!booted) interF.showChat (sender,pmsg,getPVar(id,"clr"),"GetPrivate")					break;										/*case "NC":					//new remote player dino color					var indx:int=getPVar(id,"indx");					if (indx!=-1) { if (id!=Self.id) { Players[indx].clr=msg; interF.updatePColor(indx,msg) } }					break;										case "NH":					//new remote player dino hat					var indxc:int=getPVar(id,"indx");					if (indxc!=-1) { if (id!=Self.id) { Players[indxc].hat=msg } }					break;*/										case "AR":					trace (id+"wants to join my race. maxP: "+interF.newRace.maxP+" curP: "+interF.newRace.curP)					var mAB:Array=msg.split("_");					if (interF.newRace.nam==mAB[0]) {													addPlayer (id,mAB[1]);						if (interF.newRace.curP.length+1<=interF.newRace.maxP) {  C.send ("00"+id+"RA"+mAB[0]); incomingMSG (id,"RJ",msg) } else {  C.send ("00"+id+"NA"+mAB[0]) }																			} else { C.send ("00"+id+"NA"+mAB[0]) }					break;										case "RJ":					//this player joined a race					var msgAB:Array=msg.split("_");					var allow2:Boolean=addPlayer (id,msgAB[1]);					if (interF.newRace.curP!=undefined) { if (interF.newRace.curP.indexOf(id)!=-1) { allow2=false } }					if (allow2) { addRacePlayer (id,msgAB[0]) }					break;										case "RA":					//race authorized					interF.authRace (msg);					break;										case "NA":					//not auth					interF.notAuth();					break;					case "NR":					//new race					var msgA9:Array=msg.split("_");					var nslf:Boolean=addPlayer (id,msgA9[1]);					if (nslf) { addRace (id,msgA9[0]) }					break;															case "CR":					//this player cancelled a race					if (id!=Self.id) { removeRacePlayer (id,msg) }					break;										case "NP":					//the race creator wants us to reform our players list and go to race limbo					interF.mem.curPSTR=msg;					interF.act_StartRace (0);					C.send ("00"+id+"PP");					break;									}							} else if (current=="raceLimbo") {							switch (typ) {										case "AR":					trace (id+"wants to join my race. maxP: "+interF.newRace.maxP+" curP: "+interF.newRace.curP)					var mA4:Array=msg.split("_");					trace ("no - limbo"); C.send ("00"+id+"NA"+mA4[0]);									break;										case "RJ":					//this player joined a race					/*var msgR:Array=msg.split("_");					var allow3:Boolean=addPlayer (id,msgR[1]);					if (interF.newRace.curP!=undefined) { if (interF.newRace.curP.indexOf(id)!=-1) { allow3=false } }					if (allow3) { addRacePlayer (id,msgR[0]) }*/					break;										case "PP":					//if all other players have reformed their players list, create the race room					interF.newRace.npc--;					if (interF.newRace.npc==0) {						mpc=0; 						if (Config.MMOCHA2) {							C.send ("021"+interF.newRace.nam+Self.id);						} else {							C.send ("02A01"+interF.newRace.nam+Self.id);						}					}					break;										case "RC":					//race room created... join it					trace ("race room created, join it","03"+interF.newRace.nam+id);					C.send("03"+interF.newRace.nam+id);					break;						case "LD":					//level data received;					var msgAA:Array=msg.split("-");					var xyn:Array=msgAA[1].split("_");					brain.S.xNum=Number(xyn[0]);					brain.S.yNum=Number(xyn[1]);					lvlstr+=msgAA[2];					//tell creator we got all data?					if (msgAA[0]=="X") { C.send ("00"+id+"LR") }					break;										case "LR":					//a player got our level data					interF.newRace.ldc--;					if (interF.newRace.ldc==0) { C.send("PS"+brain.dinoY+";"+brain.S.endID) }					break;										case "PS":					//start the MP race					var mAA:Array=msg.split(";");					brain.dinoY=Number(mAA[0]);					brain.S.endID=mAA[1];					brain.startMPGame();					break;					}							}					}				public function getFriendStatus (nam) {						if (brain.sys2.stats.friends.indexOf(nam.toLowerCase())!=-1) { return true } else {return false }					}				public function getBlockedStatus (nam) {						if (brain.sys2.stats.blocked.indexOf(nam.toLowerCase())!=-1&&!getFriendStatus(nam)) { return true } else {return false }					}										public function startFPStimer () {						FPStimer.addEventListener(TimerEvent.TIMER, FPSCheck);			FPStimer.start();					}				public function stopFPStimer () {						if (FPStimer!=null) { if (FPStimer.hasEventListener(TimerEvent.TIMER)) {								FPStimer.removeEventListener(TimerEvent.TIMER, FPSCheck);				FPStimer.stop();						} }					}				public function FPSCheck (ev) {						brain.newFPSCheck();					}										private function addRace (id,msg) {						var rData:Array=msg.split(",");			var allow:Boolean=true;			for each (var race in Races) { if (race.nam==rData[1]) { allow=false; break } }			if (allow) {								trace ("NEW RACE",rData);				Races.push ( {act:false, nam:rData[1], id:id, curP:rData[2].split("."), lvl:rData[3], maxP:rData[4], zone:rData[5], free:rData[6], privateID:rData[7]} )				interF.updateRaces();				//if (rData[1]=="testo") { interF.joinRace (rData[1]) }							}					}				private function addRacePlayer (id,nam) {						var race=getRVar (nam,"obj");			if (race!=-1) {				//update race list				race.curP.push (id);				interF.updateRaceNumP(nam,race.curP.length,race.maxP);										//did this person just join our race?  if so, update wait room				if (interF.current2=="waitRace") { if (interF.newRace.nam==nam) { interF.updateWaitRace() } }							}		}				private function removeRacePlayer(id,msg) {						var a:Array=msg.split(";");			var nam:String=a[0];			var cc:String=a[1];						if (cc=="1") {								var raceI=getRVar(nam,"indx");				trace ("//////////////////// RACE CANCELLED INDEX ",raceI)				if (raceI!=-1) {										//race cancelled					Races.splice(raceI,1);					interF.updateRaces();										// were we waiting for this race? if so, boot us out					if (interF.current2=="waitRace") { if (interF.newRace.nam==nam) { interF.bootFromWait() } }									}								} else {								var race= getRVar(nam,"obj");				if (race!=-1) {										race.curP.splice(race.curP.indexOf(id),1);					interF.updateRaceNumP(nam,race.curP.length,race.maxP);										//did this person cancel from our race?  if so, update wait room					if (interF.current2=="waitRace") { if (interF.newRace.nam==nam) { interF.updateWaitRace() } }									}							}					}		private function remoteConnect(id) {						trace ("//// REMOTE CONNECT",id);						if (!fcr) {								trace ("Self:",id);				Self.id=id;				current="lobby";				fcr=true;				startHB();								if (switching) { 															switching=false; 					interF.refreshLobby();										}							} else {								switch (current) {										case "lobby":					//send a private msg to this player to get their stats (if they arent already there)					var ind:int=getPVar(id,"indx");					if (ind==-1) { C.send("00"+id+"SR") }					break;										case "raceLimbo":					if (interF.newRace.act) {												if (id==Self.id) {													//we succesfully created the race room. tell others to join							sendToRoom ("RC") 													} else {														//another racer has joined our race							interF.newRace.rcc--;							if (interF.newRace.rcc==0) { brain.initMPGame() }													}											}					break;										case "lobbyCheck":					interF.current="MPLobby";					//interF.showInterX ("MPLobby"); 					current="lobby";					startHB();					break;														}							}					}							public function HB_MSG (ev) {						hbc++;			interF.chatSent=false;						//heartbeat			if (hbc>=10) { 							/*//new color info to lobby?				if (oldCLR!=Self.clr) { C.send ("NC"+Self.clr) }				oldCLR=Self.clr;								//new hat info to lobby?				if (oldHat!=Self.hat) { C.send ("NH"+Self.hat) }				oldHat=Self.hat;*/							C.send ("00"+Self.id+"HB"); 				hbc=0 ;				hbc2++;				//trace (interF.isMod(Self.nam));				var limit:int = isMod(Self.nam) ? 1000 : 30;				if (hbc2>=limit) { interF.act_SignOut (0) }							}					}				public function stopHB() {						if (HBtimer!=null) { if (HBtimer.hasEventListener (TimerEvent.TIMER)) {								HBtimer.removeEventListener(TimerEvent.TIMER, HB_MSG);				HBtimer.stop();							} }					}				public function startHB() {						hbc2=0;			HBtimer = new Timer (2000,0);			HBtimer.addEventListener(TimerEvent.TIMER, HB_MSG, false, 0, true);			HBtimer.start();					}				public function startHB2() {						HBtimer = new Timer (15000,0);			HBtimer.addEventListener(TimerEvent.TIMER, HB_MSG2, false, 0, true);			HBtimer.start();					}				public function HB_MSG2 (ev) {						C.send ("00"+Self.id+"HB");					}				public function stopHB2() {						if (HBtimer!=null) { if (HBtimer.hasEventListener (TimerEvent.TIMER)) {								HBtimer.removeEventListener(TimerEvent.TIMER, HB_MSG2);				HBtimer.stop();							} }					}				public function sendToRoom (str) {						//try {				if (cOpen) { for each (var id:String in interF.newRace.curP) { if (id!=Self.id) { C.send ("00"+id+str) } } }			//} catch (e) {}					}				public function remoteDisconnect (id) {						trace ("//////DISCONNECT",id)						switch (current) {								case "lobby":				//remove from players				var ind:int=getPVar(id,"indx");				if (ind!=-1) { Players.splice (ind,1) }				interF.updatePlayers();								//update races				for each (var race:Object in Races) {											var indx:int=race.curP.indexOf(id);					if (indx!=-1) { 											race.curP.splice(indx,1);						interF.updateRaceNumP(race.nam,race.curP.length,race.maxP);												if (race.id==id) {														//the disconnected player created this race... axe the whole thing							Races.splice(Races.indexOf(race),1);							interF.updateRaces();														// were we waiting for this race? if so, boot us out							if (interF.current2=="waitRace") { if (interF.newRace.nam==race.nam) { interF.bootFromWait() } }													} else {														// someon besides the creator left. were we waiting for this race? if so, update vars							if (interF.current2=="waitRace") { if (interF.newRace.nam==race.nam) { interF.updateWaitRace() } }													}											}									}				break;								case "raceLimbo":								break;								case "race":				if (brain.gState!="extinct") {										//remove from players					var ind2=getPVar(id,"indx");					if (ind2!=-1) {												if (brain.gState!="win") { interF.showMessage (getPVar(id,"nam")+" has leFt the race") }						interF.newRace.curP.splice(interF.newRace.curP.indexOf(id),1);						Players.splice(ind2,1);						if ( brain.rmDinos["d"+id]!=undefined) { brain.rmDinos["d"+id].deleteAll() }						delete (brain.rmDinos["d"+id]);						brain.sys2.progBar.removeMarker ("d"+id);						if (Players.length==1) {														if (brain.sys2.levelStatsMP!=undefined) {																brain.sys2.levelStatsMP.onePlayer=true;								brain.sys2.levelStatsMP.raceOver();															} else { 								if (!Brain.impacted)									brain.impact();								interF.showMessage ("All other dinos have leFt the race"); 								startHB2();							}													}											}									}				break;							}					}		public function getPVar (id,typ) {						trace ("get",id,typ);			var v=-1;			var l:int=Players.length;			for (var i:int=0; i<l; i++) {								if ((Players[i].id)==id) {					switch (typ) {												case "obj": v=Players[i]; break;						case "indx": v=i; break;						case "nam": v=Players[i].persona != "null" ? Players[i].persona : Players[i].nam; break;						case "clr": v=Players[i].clr; break;						case "score": v=Players[i].score; break;						case "lvl": v=Players[i].lvl; break;						case "hat": v=Players[i].hat; break;											}					break;									}							}						return v;					}				public function getPID (nam) {						var v:String="0";			for each (var P:Object in Players) { if (P.nam==nam || P.persona==nam) { v=P.id } }			return v;					}							public function getRVar (nam,typ) {						var v=-1;			var l:int=Races.length;			for (var i:int=0; i<l; i++) {								if (Races[i].nam==nam) {										switch (typ) {												case "indx": v=i; break;						case "obj": v=Races[i]; break;						case "creator": v=Races[i].id; break;						case "curP": v=Races[i].curP; break;						case "maxP": v=Races[i].maxP; break;											}									}							}						return v;					}				private function parseRoomList (list) {								}				private function processRoomVar (roomVar) {								}		private function error() {						switch (current) {								case "lobbyCheck": C.send ("02A00_"); break; //create lobby							}					}				//save hat, prestige & clr		public function saveStats() {						current2="saving";			setUStats ("clr",interF.dinoColors.indexOf(Self.clr))					}				//save score + race stats		public function saveStats2() {						trace ("save stats 2");			current2="savingB1";			setUStats("score",Self.score);					}				///////////////// HANDLE XML				public function processXML(xml:XML) {						trace (xml);			switch (xml.attribute("stat").toString()) {								case "ok":				switch (current) {										case "create": initUStats(); break;					case "login": getUStats(); break;					case "getStats": if (xml.child("stats").child("game").attribute("id").toString()!="dinorun") { initUStats() } else { selfStats (xml.child("stats").child("game").child("user")) }; break;					//case "initStats_score": initUStats("clr"); break;					//case "initStats_clr": initUStats("hat"); break;					//case "initStats_hat": getUStats(); break;					case "setStats":   break;									}				switch (current2) {										case "saving": current2="saving2"; setUStats ("hat",interF.hatsMP.indexOf(Self.hat)); break;					case "saving2": current2="doneSaving"; setUStats ("prestige",Self.prestige); break;					case "doneSaving": current2=""; break;										case "savingB1": current2="savingB2"; setUStats ("racesWon",brain.sys2.stats.MPracesWon); break;					case "savingB2": current2="savingB3"; setUStats ("eggs",brain.sys2.stats.MPeggs); break;					case "savingB3": current2="savingB4"; setUStats ("crittersEaten",brain.sys2.stats.MPcrittersEaten); break;					case "savingB4": current2="savingB5"; setUStats ("doomSurf",brain.sys2.stats.MPdoomSurf); break;					case "savingB5": current2="doneSavingB"; setUStats ("boulderRide",brain.sys2.stats.MPboulderRide); break;					case "doneSavingB": current2=""; break;									}				break;															case "fail":				interF.interX.alert.gotoAndStop("a"+xml.child("err").attribute("code"));				interF.preInitAlert();				break;							}					}							}	}