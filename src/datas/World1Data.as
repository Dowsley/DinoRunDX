 package datas { 	import base.Brain;
 	
 	import util.Rndm;
		public class World1Data {				public var gLvls:uint;		public var sArr:Object;		public var sData:Object;		public var spData:Object;		public var brain:Brain;		private var spc:uint;		public var undo:Object;				public static const FLAT:int = 777777;		public static const JUMPY:int = 101010;		public static const UP:int = 123456;		public static const DOWN:int = 654321;		public static const SHORT:int = 111000;						//private var jumps:Array = ["1_3T1","3_1R1","3_3T2","3_3T3"];				public function World1Data (b):void {						this.brain=b;			gLvls=4;						//vector info for screen parts			sData = {								s0_1G1 : { u:false, typs:{G:2, T:1} },				s0_1G2 : { u:false },				s0_1T1 : { u:false },				s0_2G1 : { u:false, typs:{G:2, T:1, V:1} },				s0_2G2 : { u:false },				s0_2T1 : { u:false },				s0_2V1 : { u:false },				s0_3G1 : { u:false, typs:{G:3, T:1} },				s0_3G2 : { u:false },				s0_3T1 : { u:false },				s0_4G1 : { u:false, typs:{G:2, T:1} },				s0_4G2 : { u:false },				s0_4T1 : { u:false },								s1_1S1A : { u:false },				s1_1S1B : { u:false },				s1_1S2A : { u:false },				s1_1S2B : { u:false },				s1_1S3A : { u:false },				s1_1S3B : { u:false },				s1_1S4A : { u:false },				s1_1S4B : { u:false },				s1_1S5A : { u:false },				s1_1S5B : { u:false },								s1_0G1 : { u:false, typs:{G:2, T:1} },				s1_0G2 : { u:false }, 				s1_0T1 : { u:false },				s1_1G1 : { u:false, typs:{G:3, R:1, T:2, V:2} },				s1_1G2 : { u:false },				s1_1G3 : { u:true },				s1_1R1 : { u:false },				s1_1T1 : { u:false },				s1_1T2 : { u:true  },				s1_1V1 : { u:false },				s1_1V2 : { u:false },								s1_2G1 : { u:false, typs:{G:3, R:2, T:2, V:2} },				s1_2G2 : { u:false },				s1_2R1 : { u:true  },				s1_2R2 : { u:false },				s1_2T1 : { u:false },				s1_2V1 : { u:false },				s1_2V2 : { u:false },				s1_3G1 : { u:false, typs:{G:3, R:1, T:2, V:1} },				s1_3G2 : { u:false },				s1_3G3 : { u:false },				s1_3T1 : { u:true  },				s1_3T2 : { u:false },				s1_3R1 : { u:true  },				s1_3V1 : { u:false },				s1_4G1 : { u:false, typs:{G:2, T:1} },				s1_4G2 : { u:false },				s1_4T1 : { u:false },								s2_0G1 : { u:false, typs:{G:2, T:1, V:1} },				s2_0G2 : { u:false },				s2_0T1 : { u:false },				s2_0V1 : { u:false },				s2_1G1 : { u:false, typs:{G:3, R:3, T:2, V:2} },				s2_1G2 : { u:false },				s2_1R1 : { u:true  },				s2_1R2 : { u:false },				s2_1R3 : { u:false },				s2_1T1 : { u:false },				s2_1V1 : { u:false },				s2_1V2 : { u:false },				s2_2G1 : { u:false, typs:{G:2, R:2, T:2, V:2} },				s2_2G2 : { u:false },				s2_2R2 : { u:true  },				s2_2R1 : { u:true  },				s2_2T1 : { u:true  },				s2_2T2 : { u:false },				s2_2V1 : { u:false },				s2_2V2 : { u:false },				s2_3G1 : { u:false, typs:{G:2, T:1} },				s2_3G2 : { u:false },				s2_3T1 : { u:false },				s2_4G1 : { u:false, typs:{G:3, R:1} },				s2_4G2 : { u:false },								s3_0G1 : { u:false, typs:{G:4, T:1} },				s3_0G2 : { u:false },				s3_0T1 : { u:false },				s3_1G1 : { u:false, typs:{G:3, R:3, T:2, V:1} },				s3_1G2 : { u:false },				s3_1G3 : { u:false },				s3_1R1 : { u:true  },				s3_1R2 : { u:true  },				s3_1T1 : { u:true  },				s3_1T2 : { u:false },				s3_1V1 : { u:false },				s3_2G1 : { u:false, typs:{G:2, T:1} },				s3_2G2 : { u:false },				s3_2T1 : { u:false },				s3_3G1 : { u:false, par:8, typs:{G:4, R:3, T:3, V:2} },				s3_3G2 : { u:false },				s3_3G3 : { u:false },				s3_3G4 : { u:false },				s3_3R1 : { u:true  },				s3_3R2 : { u:true  },				s3_3R3 : { u:true  },				s3_3T1 : { u:false },				s3_3T2 : { u:true  },				s3_3T3 : { u:true  },				s3_3V1 : { u:true },				s3_3V2 : { u:false },				s3_4G1 : { u:false, typs:{G:2, R:1} },				s3_4G2 : { u:false },				s3_4R1 : { u:true  },								s4_0G1 : { u:false, typs:{G:2} },				s4_0G2 : { u:false },				s4_1G1 : { u:false, typs:{G:2, T:1} },				s4_1G2 : { u:false },				s4_1T1 : { u:false },				s4_2G1 : { u:false, typs:{G:2, T:1, R:1} },				s4_2G2 : { u:false },				s4_2T1 : { u:false },				s4_3G1 : { u:false, typs:{G:2, T:2} },				s4_3G2 : { u:false },				s4_3T1 : { u:false },				s4_3T2 : { u:true  },								s0_3G3 : { u:false },				s2_4G3 : { u:false },				s4_2R1 : { u:false },				s2_4R1 : { u:false },				s3_0G4 : { u:false },				s1_2G3 : { u:false },				s2_1G3 : { u:false },				s3_1R3 : { u:false },				s3_0G3 : { u:false },				s1_2T2 : { u:false },				s2_1T2 : { u:false }							},						spData = {								A : { xNum:2, yNum:1, enterY:1, exitY:1, enterLvl:1, exitLvl:1 }, // stego lake				B : { xNum:4, yNum:1, enterY:1, exitY:1, enterLvl:3, exitLvl:3 }, // rocky 				C : { xNum:3, yNum:1, enterY:1, exitY:1, enterLvl:1, exitLvl:2 }, // small tunnel				D : { xNum:10, yNum:6, enterY:1, exitY:2, enterLvl:2, exitLvl:3 }, // drop				E : { xNum:1, yNum:2, enterY:1, exitY:1, enterLvl:3, exitLvl:2 }, // double jump				F : { xNum:3, yNum:2, enterY:1, exitY:2, enterLvl:2, exitLvl:3 }, // bronto tar pit				G : { xNum:10, yNum:4, enterY:3, exitY:1, enterLvl:1, exitLvl:2 }, // large tar pit				H : { xNum:2, yNum:1, enterY:1, exitY:1, enterLvl:1, exitLvl:3 }, // meteor deform				I : { xNum:3, yNum:2, enterY:1, exitY:1, enterLvl:2, exitLvl:2 }, // diplo tar pit				J : { xNum:12, yNum:6, enterY:4, exitY:5, enterLvl:3, exitLvl:1, lvlR:[3,6,-4,-3] }, // boulder mountain				K : { xNum:10, yNum:2, enterY:1, exitY:1, enterLvl:3, exitLvl:2 }, // cera pit				L : { xNum:4, yNum:3, enterY:1, exitY:1, enterLvl:2, exitLvl:1 }, // diplo meteor				M : { xNum:3, yNum:2, enterY:1, exitY:1, enterLvl:2, exitLvl:2 }, // anky rock pit				N : { xNum:23, yNum:5, enterY:4, exitY:5, enterLvl:1, exitLvl:2 }, // evergreen tunnels (waterfall)				O : { xNum:1, yNum:1, enterY:1, exitY:1, enterLvl:2, exitLvl:1 }, // alien meteor				P : { xNum:1, yNum:1, enterY:1, exitY:1, enterLvl:2, exitLvl:2 }, // exploding meteor hill				Q : { xNum:4, yNum:2, enterY:2, exitY:1, enterLvl:3, exitLvl:1 }, // hilly ponds				R : { xNum:1, yNum:1, enterY:1, exitY:1, enterLvl:2, exitLvl:3 }, // double impact				S : { xNum:5, yNum:3, enterY:1, exitY:1, enterLvl:1, exitLvl:1 }, // lizard cave w rinch egg				T : { xNum:5, yNum:2, enterY:2, exitY:2, enterLvl:1, exitLvl:3 }, // reverse bone cave				AA : { xNum:2, yNum:1, enterY:1, exitY:1, enterLvl:1, exitLvl:3 }, // quad meteor impact				BB : { xNum:5, yNum:1, enterY:1, exitY:1, enterLvl:3, exitLvl:0, lvlR:[5,8,-4,-4] }, // exploding meteor pond								CC : { xNum:12, yNum:3, enterY:1, exitY:1, enterLvl:2, exitLvl:2 }, // volcano lava jump				DD : { xNum:6, yNum:2, enterY:2, exitY:2, enterLvl:1, exitLvl:1 }, // volcano small				EE : { xNum:12, yNum:6, enterY:5, exitY:6, enterLvl:1, exitLvl:3, lvlR:[6,8,-3,-4] }, // volcano large				FF : { xNum:3, yNum:1, enterY:1, exitY:1, enterLvl:3, exitLvl:1 }, // volcano charred trees								U : { xNum:1, yNum:1, enterY:1, exitY:1, enterLvl:1, exitLvl:1 }, // end lvl				X : { xNum:3, yNum:2, enterY:2, exitY:2, enterLvl:1, exitLvl:2 },  // sanctuary easy rocks				XB : { xNum:4, yNum:3, enterY:3, exitY:2, enterLvl:1, exitLvl:2 }, // sanctuary medium hill				XC : { xNum:5, yNum:4, enterY:1, exitY:2, enterLvl:1, exitLvl:2 }, // sanctuary hard cave				XD : { xNum:3, yNum:3, enterY:3, exitY:3, enterLvl:1, exitLvl:1 },  // sanctuary insane aliens				XE : { xNum:6, yNum:2, enterY:2, exitY:2, enterLvl:1, exitLvl:1 } // sanctuary island							}								}				public function undoAlters() {						for (var roomID in undo) { sArr[roomID] = undo[roomID] }					}				public function arrByStr (str) {						if (brain.S.testRun) {								sArr = {};				brain.dinoY=900;				for (var xxx:int=1; xxx<=brain.S.xNum; xxx++) { sArr["r"+xxx+"_1"]="blank"}				for (var xxx2:int=1; xxx2<=brain.S.xNum; xxx2++) { sArr["r"+xxx2+"_2"]="blank"}				for (var xxx3:int=1; xxx3<=brain.S.xNum; xxx3++) { sArr["r"+xxx3+"_3"]="s1_1S1B"}				for (var X3:int=1; X3<=brain.S.xNum; X3++) { for (var Y3:int=1; Y3<=brain.S.yNum; Y3++) { brain.sys.rData.r.World1["r"+X3+"_"+Y3]=[] } }				return;							}						sArr = {};						//make array of room arays			var roomstrs:Array=str.split(";");			roomstrs.pop();			for each (var room:String in roomstrs) {								var singleRoom:Array=room.split(",");				singleRoom.pop();				var rc:Array=singleRoom[0].split("_");				sArr["r"+rc[0]+"_"+rc[1]]=singleRoom[1];							}			//go through each matrix box and fill in blanks and fills, also room data holders			for (var X:uint=1; X<=brain.S.xNum; X++) {								var dScreen:String="blank";				for (var Y:uint=1; Y<=brain.S.yNum; Y++) {										if (sArr["r"+X+"_"+Y]==undefined) { sArr["r"+X+"_"+Y]=dScreen } else { dScreen="fill" }					brain.sys.rData.r.World1["r"+X+"_"+Y]=[];														}							}					}				public function resetData () {						for (var rm in sArr) { delete sArr[rm] }			sArr = null;				}				//arrange screens		public function arrangeScreens () {									//beach?			if (brain.S.BC) {								sArr = { r1_1:"blank",r2_1:"blank",r3_1:"blank",r4_1:"blank",r5_1:"blank",r6_1:"blank",r7_1:"blank",					 	 r1_2:"blank",r2_2:"spXE1_1",r3_2:"spXE2_1",r4_2:"spXE3_1",r5_2:"spXE4_1",r6_2:"spXE5_1",r7_2:"spXE6_1",						 r1_3:"spXE0_2",r2_3:"spXE1_2",r3_3:"spXE2_2",r4_3:"spXE3_2",r5_3:"spXE4_2",r6_3:"spXE5_2",r7_3:"spXE6_2" };								for (var X3:uint=1; X3<=brain.S.xNum; X3++) { for (var Y3:uint=1; Y3<=brain.S.yNum; Y3++) { brain.sys.rData.r.World1["r"+X3+"_"+Y3]=[] } }				return;							}						if (brain.S.testRun) {								sArr = {};				brain.dinoY=900;				for (var xxx:int=1; xxx<=brain.S.xNum; xxx++) { sArr["r"+xxx+"_1"]="blank"}				for (var xxx2:int=1; xxx2<=brain.S.xNum; xxx2++) { sArr["r"+xxx2+"_2"]="blank"}				for (var xxx3:int=1; xxx3<=brain.S.xNum; xxx3++) { sArr["r"+xxx3+"_3"]="s1_1S1B"}				for (var XX3:int=1; XX3<=brain.S.xNum; XX3++) { for (var YY3:int=1; YY3<=brain.S.yNum; YY3++) { brain.sys.rData.r.World1["r"+XX3+"_"+YY3]=[] } }				return;							}						//init			sArr = {};			sData.used=[];			spData.used=[];			spData.total=brain.S.sp;			spc=0;			undo={};			var spCH = brain.S.spCH;			var spMX = brain.S.spMX;			var tg:Array = brain.S.tg;			var lvlR:Array=[0,0];			var spR:int=0;			var lastVar:String="";						//end screen info			var endID:String;			if (brain.S.lvl<brain.S.lvls) { endID="U"; brain.S.lastLvl=false } else {								brain.S.lastLvl=true;				switch (brain.S.dif) {														case "Easy":	 endID="X"; Brain.noFrenzy = true; break;					case "Medium":	 endID="XB"; break;					case "Hard": 	 endID="XC"; break;					case "Insane":	 endID="XD"; break;													}								if (brain.S.mod=="SpeedRun"||brain.S.mod=="MP") { endID=brain.S.endID }				if (brain.S.mod=="PlanetD") {endID = "XC"}				if (brain.S.mod=="Halloween") {endID = "X"}				brain.S.endID=endID;							}						var endX=brain.S.xNum-spData[endID].xNum;			//trace ("//////SA",brain.S.xNum,spData[endID].xNum,endX);			var beginLvl:uint;			var endLvl:uint;						//typs: grass, rock, tree			var typs:Array = brain.S.tt.slice();			var prefTyp:String = typs[0];			var typMax:uint=rand(3,6);			var typC:uint=0;						//seed code specials			var useFLAT:Boolean = Brain.useSeed==FLAT;			var useJUMPY:Boolean = Brain.useSeed==JUMPY;			var useUP:Boolean = Brain.useSeed==UP;			var useDOWN:Boolean = Brain.useSeed==DOWN;			var useSHORT:Boolean = Brain.useSeed==SHORT;						//useJUMPY = true;						//mandatory special area?			var msp:Boolean=(brain.S.msp.id=="")?false:true;			var mspID="";			var mspX=0;			var mspY=0;			var mspPlot:Boolean=false;			if (msp) {								mspID=brain.S.msp.id;				mspX=brain.S.msp.px;				mspY=brain.S.msp.py;								if (useJUMPY) {					mspID = "E";				}							}						//first screen			var nextY:uint=rand(tg[0][0],tg[0][1]);						if (useUP) {				brain.S.yNum = 100;				nextY = brain.S.yNum-1;			}						if (useDOWN) {				brain.S.yNum = 100;				nextY = 2;			}						tg.splice(0,1);			sArr["r1_"+nextY]="s1_1S"+brain.S.st+"A";			//start Y for dino			brain.dinoY=((nextY-1)*450)+((4-nextLvl)*100);			//fill above and below			for (var YF:uint=nextY+1; YF<=brain.S.yNum; YF++) { sArr["r1_"+YF] = "fill" }			for (var YF2:uint=1; YF2<nextY; YF2++) { sArr["r1_"+YF2] = "blank" }						//2nd screen			sArr["r2_"+nextY]="s1_1S"+brain.S.st+"B";			//fill above and below			for (var YF3:uint=nextY+1; YF3<=brain.S.yNum; YF3++) { sArr["r2_"+YF3] = "fill" }			for (var YF24:uint=1; YF24<nextY; YF24++) { sArr["r2_"+YF24] = "blank" }			var nextLvl:uint=1;						//3rd screen?			var firstV:Boolean=(brain.S.st==6)?true:false;			if (firstV) {								sArr["r3_"+nextY]="s1_1S"+brain.S.st+"C";				//fill above and below				for (var YF4:uint=nextY+1; YF4<=brain.S.yNum; YF4++) { sArr["r3_"+YF4] = "fill" }				for (var YF6:uint=1; YF6<nextY; YF6++) { sArr["r3_"+YF6] = "blank" }							}						//do the rest			if (Brain.SHORT) {				brain.S.xNum = 5;				endX = 5;			}			if (useSHORT) {				brain.S.xNum = Math.round(brain.S.xNum/2);				endX = Math.round(endX/2);			}			var spFlag:Boolean = false;			for (var X:uint=firstV?4:3; X<=endX; X++) {								//new lvlRange?				spR--;				if (spR<0) { spR=0 }				if (spR==1) { if (tg.length>0) { lvlR=tg[1].slice() } }				if (tg.length>0&&X>=tg[0]&&spR==0) { lvlR=tg[1].slice(); tg.splice(0,2) }												//Y of ground				var currentY:uint=nextY;								//level of ground				beginLvl=nextLvl;				var endLvlMin:int = beginLvl+lvlR[0];				if (endLvlMin<0) { endLvlMin=0 }				if (endLvlMin>4) { endLvlMin=4 }				var endLvlMax:int = beginLvl+lvlR[1];				if (endLvlMax<0) { endLvlMax=0 }				if (endLvlMax>4) { endLvlMax=4 }				endLvl=rand(endLvlMin,endLvlMax);				if (useJUMPY && Math.random() < .75) {					if (beginLvl == 3 && Math.random() < .5) {						endLvl = 3;					} else {						endLvl = Math.random() < .5 ? 3 : 1;					}				}												//steer ground level towards mandatory special area Y?				if (msp) {										if (X<mspX||!mspPlot) {												var xDif=mspX-X;						var yDif=mspY-currentY;												if (rand(0,xDif-5)<1) {														//steer it							if (yDif!=0) {															if (yDif<0) { endLvl=4 } else { endLvl=0 }															} else {																endLvl=rand(1,3);															}													}												//plot it now?						if (X>=mspX&&yDif==0) { mspPlot=true; msp=false }											}									}								//UP				if (useUP) {					//beginLvl = 0;					endLvl= this.rand(beginLvl,4);					//nextY--;					if (nextY < 3) {						useUP = false;					}				}								//UP				if (useDOWN) {					//beginLvl = 0;					endLvl= this.rand(beginLvl,0);					//nextY--;					if (nextY > brain.S.yNum-1) {						useDOWN = false;					}				}												//adjust endLvls				if (beginLvl==gLvls&&endLvl==gLvls) { endLvl=gLvls-1 } //cant have two top lvls				if (beginLvl==0&&endLvl==0) { endLvl=1 } //cant have two bottom lvls																				//end level limits and next Y				//dont go all the way down				if (currentY==(brain.S.yNum-1)&&endLvl==0) { endLvl=1; lvlR=(tg.length>0)?tg[1].slice():[-3,3]; nextLvl=endLvl } else {										if (endLvl==gLvls) {												//dont go all the way up						if (currentY==2) { endLvl=gLvls-1; lvlR=[-3,3]; nextLvl=endLvl } else { nextY--; nextLvl=0 }											} else if (endLvl==0) { nextY++; nextLvl=gLvls } else { nextLvl=endLvl }									}												//flat								if (useFLAT) {					if (spFlag) {						beginLvl = nextLvl;						endLvl= 1;						spFlag = false;					} else {						beginLvl = endLvl= 1;					}					nextY = currentY;				}																		//special area in the next screen?				var spXJump:uint=0;				spc++;				if (rand(0,spCH)==0 || X>=endX || spc>spMX || mspPlot) {										spc=0;					//used em all up?										if (spData.used.length<spData.total.length||X>=endX||mspPlot) {											//which area?						if (X>=endX) {													spID=endID;													} else if (mspPlot) {														spID=mspID;							mspPlot=false;													} else {														do {																if (useJUMPY) {									spID = "E";									break;								}								var spID:String=spData.total[rand(0,spData.total.length-1)];								if (spData.used.indexOf(spID)==-1) { break }															} while (true);														//spID="L";													}						var spD:Object = spData[spID];						//will it fit?						if ((currentY+(spD.yNum-spD.enterY)<=brain.S.yNum-((spD.exitLvl==0)?2:1) && currentY-spD.enterY>1 && X+spD.xNum<endX-1)||X>=endX||mspPlot) {														//it fits, do it							//add to used							for each (var id:String in spData.total) { if (spID==id) { spData.used.push (spID) } }														//set x jump							spXJump=spD.xNum;							//adjust this current screens end Lvl							endLvl=spD.enterLvl;							//set ground level and nextY for after x jump							var yA:uint=0;							trace ("special",spD.exitLvl);							if (spD.exitLvl==0) {																nextLvl=gLvls;								yA=1;															} else { nextLvl=spD.exitLvl; spFlag = true; }							nextY=currentY+(spD.exitY-spD.enterY)+yA;							if (spD.lvlR!=undefined && !brain.S.RT) {																spR=rand(spD.lvlR[0],spD.lvlR[1]);								lvlR=[spD.lvlR[2],spD.lvlR[3]] 															};														//fill in all the special screens							for (var XS:uint=1; XS<=spD.xNum; XS++) {																//main areas								for (var YS:uint=1; YS<=spD.yNum; YS++) {																		var sX:int=X+XS;									var sY:int=currentY-spD.enterY+YS;									sArr["r"+sX+"_"+sY] ="sp"+spID+XS+"_"+YS;																		//extend beyond world limimts? (sanctuary)... add room data holder									var exp:Boolean=false;									if (sX>brain.S.xNum) { brain.S.xNum=sX; exp=true }									if (sY>brain.S.yNum) { brain.S.yNum=sY; exp=true }									if (sY<1) { exp=true }									if (exp) { brain.sys.rData.r.World1["r"+sX+"_"+sY]=[] }																	}																//below ground is filled								for (var YAS:uint=currentY+(spD.yNum-spD.enterY)+1; YAS<=brain.S.yNum; YAS++) {															sArr["r"+(X+XS)+"_"+YAS] = "fill";														}																//above ground is blank								for (var YBS:uint=1; YBS<=currentY-spD.enterY; YBS++) {															sArr["r"+(X+XS)+"_"+YBS] = "blank";														}															}													}											}									}																//decide terrain type				var screen:String = "s"+beginLvl+"_"+endLvl;				var typsO:Object = sData[screen+"G1"].typs				var typA:Array=[];								//if this object has the preferred type in it, create just that array. 				for (var typ in typsO ) {										if (typ==prefTyp) {												for (var i:int=1; i<=typsO[typ]; i++) { typA.push (typ+i) }						break;											}									}								//else use just grass				if (typA.length==0) { for (var ii:int=1; ii<=typsO.G; ii++) { typA.push ("G"+ii) } }												//decide type variation, but dont use unique variations already used or variations just used in the previous screen				var tVar:String;				var tc:uint=0;				do {										tVar=typA[rand(0,typA.length-1)];					if (sData.used.indexOf(screen+tVar)==-1||screen+tVar!=lastVar) { break }										//possibly already used all uniques for this type?					tc++;					if (tc>20) {												//just use grass						typA=[];						for (var k:int=1; k<=typsO.G; k++) { typA.push ("G"+k) }						tVar=typA[rand(0,typA.length-1)];						break;											}				} while (true);								//jumpy				if (useJUMPY) {					switch (beginLvl+"_"+endLvl) {						case "1_3": tVar = "T1"; break;						case "3_1": tVar = "R1"; break;						case "3_3": tVar = Math.random() < .333 ? "T2" : "T3"; break;					}				}												//record uniques + lastVar								var fScreen:String=screen+tVar;				lastVar=fScreen;				if (sData[fScreen].u) { sData.used.push(fScreen) }								//define it in screen arrangement				sArr["r"+X+"_"+currentY] = fScreen;				//below ground is filled				for (var YA:uint=currentY+1; YA<=brain.S.yNum; YA++) { sArr["r"+X+"_"+YA] = "fill" }				//above ground is blank				for (var YB:uint=1; YB<currentY; YB++) { sArr["r"+X+"_"+YB] = "blank" }												//jump ahead?				X+=spXJump;								//change preferred terrain type?				typC++;				if (typC>typMax) {										prefTyp = typs[rand(0,typs.length-1)];					typMax=rand(2,6);					typC=0;									}			}						//create empty room data objects and create arrstr			for (var X2:uint=1; X2<=brain.S.xNum; X2++) {								for (var Y2:uint=1; Y2<=brain.S.yNum; Y2++) {										brain.sys.rData.r.World1["r"+X2+"_"+Y2]=[];														}							}		}				public function createEmptyRooms () {						for (var X2:uint=1; X2<=brain.S.xNum; X2++) {								for (var Y2:uint=1; Y2<=brain.S.yNum; Y2++) {										brain.sys.rData.r.World1["r"+X2+"_"+Y2]=[]									}							}					}										//create room data		public function createRoomData (vd,useSTR,str) {									//string for lvlSend			var lvlstr:String="";						//use string?			//make array of room arays			if (str!="") {								var rooms:Object={};				var roomstrs:Array=str.split(";");				roomstrs.pop();								for each (var roomS:String in roomstrs) {										var singleRoom:Array=roomS.split(",");					singleRoom.pop();					rooms["r"+singleRoom[0]]=(singleRoom.length>2)?singleRoom.splice(2,singleRoom.length-2):[];									}							}			//define a room			for (var rm in vd) {				var plotSemi:Boolean=false;				if (sArr[rm]!="blank"&&sArr[rm]!="fill") {										lvlstr+=(rm.substring(1,rm.length)+","+sArr[rm]+",");					plotSemi=true;									} 				if (rm.charAt(0)=="b") { brain.sys.rData.r.World1[rm] = [] }				var room:Array=brain.sys.rData.r.World1[rm];				var roomO:Object = vd[rm];				var rmA:Array=rm.split("_");				//define item positions				for (var id in roomO.itms) {					var px:Number=roomO.itms[id][0];					var py:Number=roomO.itms[id][1];					var lvl=id.substring(2,3);					//trace (id)					var a2:Boolean=false;					if (useSTR) { a2=(rooms[rm].indexOf(id)!=-1)?true:false }					//trace (id.substring (0,2));					switch (id.substring (0,2)) {												//speed boost						case "sb":						if (allow(id,10,a2,useSTR)) { room.push ( {nam:"Pup", typ:"speedBoost", lvl:lvl, px:px, py:py, front:true, depth:["world","bgx"]} ); lvlstr+=(id+",") }						break;												//super jump						case "sj":						if (allow(id,8,a2,useSTR)) { room.push ( {nam:"Pup", typ:"superJump", lvl:lvl, px:px, py:py, front:true, depth:["world","bgx"]} ); lvlstr+=(id+",") }						break;												//egg						case "eg":						if (allow(id,8,a2,useSTR) && !brain.S.ED && !brain.S.NL) { 													room.push ( {nam:"Egg", typ:lvl, px:px, py:py, d:false, depth:["world","main"]} ); lvlstr+=(id+",");							//brain.sys2.stats.eggsTotal++;													}						break;												//boulder						case "bd":							if (brain.S.df) {								break;							}						var cv:int = (30-brain.S.bm-brain.S.lv)-((Math.round(px/(brain.sDim.w*(brain.S.xNum/14))))+5)						if (cv<1) { cv=1 }						if (brain.S.lvl==1&&px<2500) { cv==100000 }						if (allow(id,cv,a2,useSTR)&&rand(0,brain.S.meteors?5:25-(2*brain.S.difNum))<5  && !brain.S.ED) {														var a:Boolean=true;							if (!brain.S.bb&&lvl==5) { a=false }							if (a) {																if ((rand(0,36-(brain.S.lv*5))==0)&&brain.S.mod!="MP") {																		room.push ( {nam:"Meteorite", lvl:lvl-1, px:px, py:py, depth:["world","fgx"]} ); lvlstr+=(id+",");																	} else {																		room.push ( {nam:"Boulder", lvl:lvl, px:px, py:py, depth:["world","main"]} ) ; lvlstr+=(id+",");																	}															}													}						break;												//runner						case "rn":						if (allow(id,9,a2,useSTR) && !brain.S.ED && !brain.S.df) { room.push ( {nam:"Runner", px:px, py:py, free:(lvl=="F")?true:false, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//para						case "pa":						if (lvl=="r" || brain.S.mod != "MP") {														if (allow(id,9,a2,useSTR)&&brain.S.mod!="MP") { room.push ( {nam:"Para", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }													} else {														if (Number(lvl)<=brain.sys.MP.Players.length) { room.push ( {nam:"Para", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }																																												}																											break;												//lizard						case "li":						var ca:Array = ["G","O","P"];						if (allow(id,brain.S.LZ?5:9,a2,useSTR) && !brain.S.ED) { room.push ( {nam:"Liz"+ca[rand(0,2)], px:px, py:py, free:(lvl=="F")?true:false, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//stego						case "st":						trace ("stego",brain.S.NS);						if (allow(id,brain.S.SS?5:8,a2,useSTR) && !brain.S.ED && !brain.S.NS) { trace ("allowed"); room.push ( {nam:"Stego", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//dactyl						case "dc":						if (allow(id,9,a2,useSTR)) { room.push ( {nam:"DactylFG", px:px, py:py, wait:true, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//cera						case "ce":						var id2:String=id.substring(3,4);						if (id2=="c") {														if ((allow(id,brain.S.CS?5:9,a2,useSTR)&&brain.S.tr) && !brain.S.ED) { room.push ( {nam:"Cera", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }													} else {														if (lvl<=brain.S.difNum && !brain.S.ED) { room.push ( {nam:"Cera", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }													}						break;												//birdFG						case "bf":						if (allow(id,8,a2,useSTR)) { room.push ( {nam:"BirdFG", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//jump area						case "ja":						if (allow(id,10,a2,useSTR)) { room.push ( {nam:"JumpArea", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",") }						break;												//rev area						case "ra":						if (allow(id,10,a2,useSTR)) { room.push ( {nam:"RevArea", px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",") }						break;												//splash						case "sp":						room.push ( {nam:"Splash", px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//big splash						case "bs":						room.push ( {nam:"BigSplash", px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//bones						case "bo":						room.push ( {nam:"Bones", px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//leaves						case "lf":						if (brain.S.colorV!="V") { room.push ( {nam:"Leaves", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",") }						break;												//pine needles						case "pn":						room.push ( {nam:"Pines", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//special event						case "ev":						var xa:int=0;						var ya:int=0;						if (lvl=="B") { xa=rand(-120,0) }						if (lvl=="C") { xa=rand(-80,0); ya=rand(0,80) }						room.push ( {nam:"SpecialEvent", typ:lvl, px:px+xa, py:py+ya, depth:[0,0]} ); lvlstr+=(id+",");						break;												//slow						case "sl":						room.push ( {nam:"Slow", px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//big boulder						case "bb":						room.push ( {nam:"BoulderLG", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",");						break;												//fish						case "fi":						room.push ( {nam:"Fish", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",");						break;												//drop boulder						case "dr":						if (brain.S.df)							break;						room.push ( {nam:"Boulder", lvl:lvl, px:px, py:py, drop:true, depth:["world","main"]} ); lvlstr+=(id+",");						break;												//worm						case "wr":						if (allow(id,9,a2,useSTR)) { room.push ( {nam:"Worm", px:px, py:py, rev:rand(0,1)==0?true:false, depth:["world","main"]} ); lvlstr+=(id+",") }						break;												//super egg						case "se":						if (brain.sys2.stats.superEggsPL.indexOf(lvl)==-1 || brain.S.mod=="MP") {														room.push ( {nam:"SuperEgg", typ:lvl, px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",");							brain.sys2.stats.superEggsTotal++;													}						break;												//strength plant						case "sr":						var sv:int=(brain.S.lv<3)?1000:10;						if (allow(id,sv,a2,useSTR)) {  room.push ( {nam:"Pup", typ:"strength", lvl:lvl, px:px, py:py, front:true, depth:["world","bgx"]} ); lvlstr+=(id+","); }						break;												//meteorite						case "mt":						if (allow(id,8,a2,useSTR)) { room.push ( {nam:"Meteorite", lvl:lvl, px:px, py:py, depth:["world","fgx"]} ); lvlstr+=(id+","); }						break;												//lava						case "la":						room.push ( {nam:"Lava", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//vent						case "vn":						room.push ( {nam:"Vent", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//vent						case "cg":						room.push ( {nam:"Gen", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//vent						case "fx":						room.push ( {nam:"FXGen", lvl:lvl, px:px, py:py, depth:[0,0]} ); lvlstr+=(id+",");						break;												//dude						case "du":						if (brain.S.mod!="MP"&&brain.sys2.stats.trophies.buddyFound=="") { room.push ( {nam:"Dude", px:px, py:py, depth:["world","main"]} ); lvlstr+=(id+",") }						break;											}									}								if (plotSemi) { lvlstr+=";" }			}						return lvlstr;								}				public function defineRoomDataByStr (str) {						//make array of room arays			var roomstrs:Array=str.split(";");			roomstrs.pop();			for each (var room:String in roomstrs) {								var singleRoom:Array=room.split(",");				var rc:Array=singleRoom[0].split("_");				sArr["r"+rc[0]+"_"+rc[1]]=singleRoom[1];							}					}				private function allow (id,num,rd,useSTR) {						var allow:Boolean=true;			if (useSTR) { return rd } else if (id.substring(3,4)=="c") {								allow=false;				if (rand(1,num)<6) { allow=true }			}			return allow;					}					// give a rounded random number		private function rand(min:int, max:int):int {			return (Math.round(Rndm.random()*(max-min))+min);			//return (Math.round(Math.random()*(max-min))+min);		}			}	}