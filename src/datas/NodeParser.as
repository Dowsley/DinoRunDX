package datas {		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;		public class NodeParser extends Sprite {				private var cRooms:Array;		private var cWorldNodes:MovieClip;		private var roomC:int;		private var cn:uint=0;				public var cWorld:String;		public var v:Object;		public var brain:Object;		public var wData:Object;		private var nodeTypes:Array = ["a","b","c","d","e","f","g"];				public function NodeParser ():void {						//current world			cWorld="World1";						//define main data object			v = {};						//init index counter			roomC=-1;						//frame function			addEventListener (Event.ENTER_FRAME, defineV);						//do it!			defineWorld();		}				public function defineV (event:Event):void {						cn++;			if (cn>2) {							var room:String = cRooms[roomC];				//trace (brain.world.sArr[room]);				trace (room);								//define datas				v[cWorld][room].lns={};				var ld:Object = v[cWorld][room].lns;								var rData:Object = wData.vData[room];								//define ground nodes				var gn:Object = rData.vNodes;				var n:uint = 0;				var nt:uint = 0;				for (var t in gn) { nt++ }				for (var ntn:uint=0; ntn<nt; ntn++) {										var typ:String = nodeTypes[ntn];					var num:uint = gn[typ];					for (var i:uint=1; i<=num; i++) {												n++;						//trace (typ,i);						ld["l"+n]={x1:cWorldNodes[typ+i].x,y1:cWorldNodes[typ+i].y,x2:cWorldNodes[typ+(i+1)].x,y2:cWorldNodes[typ+(i+1)].y};											}									}								//define item positions				v[cWorld][room].itms={};				var id:Object = v[cWorld][room].itms;				var ip:Object = rData.itms;				for (var typ2 in ip) {										var num2:uint = ip[typ2];					for (var ii:uint=1; ii<=num2; ii++) {												id[typ2+ii]=[Math.round(cWorldNodes[typ2+ii].x),Math.round(cWorldNodes[typ2+ii].y)];											}									}								//output				nextRoom();							}					}				private function defineWorld () {						roomC=-1;						//create new worldClip			cWorldNodes = new World1Nodes();						//create world node data			wData = new NodeData ();						//define rooms			cRooms = [];			for (var room in wData.vData) { cRooms.push (room) }			cRooms.sort();						v[cWorld]={}			//start process			nextRoom();					}				private function nextRoom () {						roomC++;			v[cWorld][cRooms[roomC]]={};						//hit max room for this world?  if so, exit.  if not, define room.			if (roomC>=cRooms.length) {								removeEventListener (Event.ENTER_FRAME, defineV);				output ();							} else {								try { cWorldNodes.gotoAndStop (cRooms[roomC]); } catch (e){}							}					}				private function output () {						var ind:String="                ";						trace ();trace ();trace ();trace ();			trace (ind+cWorld+": {");			for (var screen in v[cWorld]) {								trace (ind+"    "+screen+": {");												var n:int=0;				for (var q in v[cWorld][screen].lns) { n++ }							var c:int=0;				var lnTxt:String="";				for (var ln in v[cWorld][screen].lns) {										c++;					var l=v[cWorld][screen].lns[ln];					lnTxt+=(ln+": {x1:"+Math.round(l.x1)+",y1:"+Math.round(l.y1)+",x2:"+Math.round(l.x2)+",y2:"+Math.round(l.y2)+"}"+(c==n?"":","));									}								trace (ind+"        lns: { " +lnTxt+" },")												var nn:int=0;				for (var qq in v[cWorld][screen].itms) { nn++ }								var cc:int=0;				var itmsTxt:String=""				for (var it in v[cWorld][screen].itms) {										cc++;					var i=v[cWorld][screen].itms[it];					var xtra2=(cc==nn?"":",")					itmsTxt+=(it+":["+i+"]"+xtra2);									}				if (itmsTxt!="") { trace (ind+"        itms: { "+itmsTxt +" }") } else { trace (ind+"        itms: {}") }															trace (ind+"    },");							}						trace (ind+"}");					}	}	}