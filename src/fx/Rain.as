package fx {		import gfx.RainDrop;		public class Rain {				private var c:uint;		private var cMax:uint;		private var cEnd:uint;		private var brain:Object;		private var phase:String;		private var m:Number;		private var m2:Number;		private var mI:Number;		private var mI2:Number;		private var rd:Object;		private var rdc:Number;		private var rdch:Number;				public function Rain (brain:Object,cMax:uint):void {						this.cMax=cMax;			this.brain=brain;			c=0;			cEnd=cMax-250;			m=1;			m2=1;			mI=(1-.5)/250;			mI2=(1-.75)/250;						rd={};			rdch=0;			rdc=0;					}				public function main () {						c++;			var cc:Boolean = (brain.doom.dif<brain.doom.rng)?false:true;			if (c<250) {								//rain in				if (cc) {										//bg blue					m-=mI;					brain.sky.cc.cChange ([0,0,0,m,m,1,1]);					brain.worldBG.cc.cChange ([0,0,0,m,m,1,1]);										//fg darken					m2-=(brain.dino.ug?-1*mI2:mI2);					if (m2>1) { m2=1 }					brain.world.bgCC.cChange ([0,0,0,m2,m2,m2,1]);					brain.world.mainCC.cChange ([0,0,0,m2,m2,m2,1]);					brain.world.fgCC.cChange ([0,0,0,m2,m2,m2,1]);									}								rdch=((250-c)/5)+5;							} else if (c>cEnd&&c<=cMax) {								//rain out								if (cc) {										//bg blue					m+=mI;					brain.sky.cc.cChange ([0,0,0,m,m,1,1]);					brain.worldBG.cc.cChange ([0,0,0,m,m,1,1]);										//fg lighten					m2+=mI2;					if (m2>1) { m2=1 }					brain.world.bgCC.cChange ([0,0,0,m2,m2,m2,1]);					brain.world.mainCC.cChange ([0,0,0,m2,m2,m2,1]);					brain.world.fgCC.cChange ([0,0,0,m2,m2,m2,1]);									}								rdch=(20-((cMax-c)/10))*2;							} else { 							rdch=4 ;				if (brain.dino.ug) {										if (m2<1) {												m2+=(mI2*5);						if (m2>1) { m2=1 }						brain.world.bgCC.cChange ([0,0,0,m2,m2,m2,1]);						brain.world.mainCC.cChange ([0,0,0,m2,m2,m2,1]);						brain.world.fgCC.cChange ([0,0,0,m2,m2,m2,1]);											}									} else {										if (m2<=1&&m2>.55&&c<cMax) {												m2-=(mI2*5);						brain.world.bgCC.cChange ([0,0,0,m2,m2,m2,1]);						brain.world.mainCC.cChange ([0,0,0,m2,m2,m2,1]);						brain.world.fgCC.cChange ([0,0,0,m2,m2,m2,1]);											}									}								//keep bg blue				brain.sky.cc.cChange ([0,0,0,m,m,1,1]);				brain.worldBG.cc.cChange ([0,0,0,m,m,1,1]);												}						//raindrops			//create new?			if (!brain.dino.ug) {								if (rand (0,rdch)<3) {										if (c<cMax) {										rdc++;						rd["r"+rdc]={};						var trd:Object=rd["r"+rdc];						trd.speed=rand2(13,20);						trd.yo=brain.dino.pos.y-450;						trd.ref = new RainDrop (brain.dino.pos.x+rand(-600,600),trd.yo,trd.speed);						brain.world.bgx.addChild (trd.ref);											}								}							}			//move existing			var yMax = brain.dino.y+300;			var rc:uint=0;			for (var r in rd) {								rc++;				var ro:Object = rd[r];				ro.ref.x+=ro.speed+rand2(2.5,3.5);				ro.ref.y+=ro.speed;				if (ro.ref.y>yMax) {										brain.world.bgx.removeChild (ro.ref);					ro.ref=null;					delete rd[r];									}							}						//lightning			if (Math.random()<.01) { brain.weather.lStrike(rand(1,3),rand2(.2,.7)) }						//end?			if (c>=cMax) {								brain.sky.cc.cChange ([0,0,0,1,1,1,1]);				brain.worldBG.cc.cChange ([0,0,0,1,1,1,1]);				brain.world.bgCC.cChange ([0,0,0,1,1,1,1]);				brain.world.mainCC.cChange ([0,0,0,1,1,1,1]);				brain.world.fgCC.cChange ([0,0,0,1,1,1,1]);							}			if (c>=cMax+20&&rc==0) { remove() }					}				public function end():void		{			c = cEnd;		}				public function remove () {						for (var r in rd) {								var ro:Object = rd[r];				brain.world.bgx.removeChild (ro.ref);				ro.ref=null;				delete rd[r];							}						brain.removeSYS2 ("rain");			brain=null;			rd=null;					}				// give a rounded random number		public function rand(min:int, max:int):int {			return (Math.round(Math.random()*(max-min))+min);		}		// give an unrounded random number		public function rand2(min:Number, max:Number):Number {			return (Math.round(((Math.random()*(max-min))+min)*100))/100;		}			}	}